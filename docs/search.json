[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Java编程四部曲",
    "section": "",
    "text": "1 为什么我一下子有了四本书稿呢？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n长期听我电台的人可能知道，大约4年前我就说，我正在写一本“Java编程”的书。第一次写书，激情满满，很快就写完了“初稿”，就跟当初录电台一样，一天录一期。但是“初稿”与“出版”之间的距离非常遥远——大约是大唐到灵山的距离吧，期间要经历九九八十一难，才有可能出版。我以前又没出过书，算是初生牛犊不怕虎，写就完了……\n“写书”与“录电台”是容易形成“习惯”的，把书稿交给出版社后，就跟失恋了一样，心里空落落的，还是想每天写点东西。我有个“自以为是”的优点，我能把一件事情坚持下来，坚持很久。\n\n\n\n\n\n\n“坚持”并不一定是好事，要分情况\n\n\n\n以前我“天真”的认为，坚持是一种好的品质，但是在遭遇很多磨难之后，我才意识到，如果“对错误的人与事，坚持不如早点放弃”。\n对个人可以掌控的事情——这种事不多——坚持还是有用的。\n比如我坚持每个月录3-4期电台，坚持了9年，现在正在奔向500期电台的路上，我觉得这已经是我的生活休闲的方式。\n比如我坚持背单词，当年听了新东方俞敏洪的忽悠，坚持背单词，后来我就成了学霸，英语大概都能考到90%的分数。\n比如写书，我当初加入了豆瓣一个小组，叫每天写1000字……刚开始觉得有点难，后来，我每天写技术书，平均可以写2500-3000字，这就是这四本书的来历。\n但是，有些事情是坚持不能改变的，就像你不能坚持每天用一杯25摄氏度的水，想用4天的时间凑出100摄氏度的水。如果路一开始就走错了，越坚持，错的就越离谱。\n\n\n出版一本书，更多的是“修改”，而创作一本书，更多的是“炫耀”。我喜欢“炫耀”我懂的多，而不是“修改”细枝末节。\n不经历过不知道，在漫长的等待过程中，我觉得我还是继续写点书吧，毕竟只写一本，好像“虚荣”的不够劲。就像我想抽大烟，结果只抽了一根香烟，不过瘾。索性又写了三本，当时的想法是出一本，然后再出一本，继续出一本，最后出一本，搞个“Java编程四部曲”，过过瘾。\n\n\n\n\n\n\n著名的几部曲\n\n\n\n比较出名的东西，都是三部曲，四部曲呢……\n比如《家》《春》《秋》、《教父》、《黑客帝国》、《多情剑客无情剑》、《边城浪子》、《九月鹰飞》、《天涯·明月·刀》、《飞刀，又见飞刀》……\n所以我也想试试。\n\n\n九九八十一难，结果第一难都没熬过去。主要还是我个人生活上的失败，遇人不淑，滥生无辜……人到中年，低头发现胸口插了一把刀子，还是从背后插的。\n死倒是没死，但是痛是真痛。浑浑噩噩的开始收拾残局，该断的断，该舍的舍，该离的离。\n其中就包括这几本书，电台的听众，总是时不时的问起我，我只能说，再等等看。一般来说，我都把初稿发给他们一部分，比如前4章。第一本书我写了21章，跟出版社搞了3年，才磨到第5章。如果按照这个进度，等着出版，要10年吧。再加上Java市场低迷，人工智能异军突起，传统的编程书就是鸡肋啦，我自己也衡量了一下，我的书，若是出版，极大的概率是最后按斤卖给废品站回收处理，对地球也是一种伤害。\n不应该的坚持，对别人是一种伤害，不如放手。出版的梦也就惊醒了，结果，我现在手里有了4本书的书稿 :)\n\n\n2 这四本书要100万字，不想开源，想卖电子书\n这四本书我就在网上卖电子版好了。这四本书总共200元。因为是电子书，按照互联网的规则，其实只能“卖”一本，然后其它就可以“免费”阅读了。这个我是知道的，所以我搞了一个社区叫学伴：https://xueban.app，如果你购买了这四本书，我会拉你到这个社区里。\n这个社区的主要话题是：学技术、学外语、搞事业。 在购买页面里，我会详细讲一下我做这个社区的想法。\n如何购买呢？我专门写了一个购买的介绍，介绍了这四本书的购买。\n链接如下： 如何购买这四本电子书？",
    "crumbs": [
      "Java编程",
      "Java编程四部曲"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "Home",
      "About"
    ]
  },
  {
    "objectID": "chapter0.html",
    "href": "chapter0.html",
    "title": "导读",
    "section": "",
    "text": "1 这本书适合谁\n《Java》是一本介绍Java编程的书。对Java编程感兴趣，并想使用Java语言开发软件，无论是给安卓手机开发软件，还是想用Java开发网站，甚至中间件的人，都可以从本书中获得最重要的基础知识。\n本书的副标题是“有趣有料的Java编程”。如果你是一位对Java编程语言和计算机历史有强烈兴趣的爱好者，想必你一定也想了解编程语言和编程范式背后的故事，本书也能够充分的满足你的要求。副标题里的有趣和有料，对本书来说，意味着收集了很多有趣的编程故事，根据这些故事，再挖掘故事背后的历史真相。\n事实上，依我所见，最好的学习方法是通过追溯编程语言的发展历史，了解语言从何产生，因何变化，一边在历史中考证语言的进化，一边在实践中学习编程的技巧，边考据，边学习。只有这样，才能更深入的理解语言进化的脉络，更真切的领会语言设计者的意图。\n如果你认同以上的观点，那么这本书就适合你。\n\n\n2 需要什么技术基础\n从什么技术层面切入到Java编程领域？这是一个非常容易引起争论的话题。类似的问题还有学编程要求数学很好么？哪一门语言最适合初学者？要先学数据结构或者操作系统么？英语不好能学编程么？我认为学习编程和其它事情一样，比如学吉他、吹口琴、做蛋糕、追女孩…… 最大的障碍是：行动。\n我们初中学过一篇清代文学家彭端淑写的古文，名字叫《为学》。在这篇文章中，讲了两个四川的和尚要去南海，一贫一富，富者说他准备了好几年，要买一艘船顺着长江去南海。穷和尚说他只有一个盛水的瓶一个盛饭的碗。过了一年，穷和尚从南海归来，而富和尚还在准备。\n现在都已经是AI时代了，能搞明白个20%就开始动手吧。否则，光精神内耗，不停的纠结要不要做，纠结十个月，你喜欢的女生都给别人生孩子了。先上车再补票，实在不行，再下车呗，反正也没买票，还多了一段乘车的体验。\n善于下大棋，看二十步还没走一步的人，别说在AI时代了，就算在任何时代都活不过一集。比如，1807发生了第二次哥本哈根战役，丹麦的海军被英国摧毁，哥本哈根这个城市还被炮击。丹麦投降，但是痛定思痛，觉得这样不行，要建立一支舰队再跟英国人搞一次，一血前耻！他们就种植了大量的橡树，无奈橡木生长缓慢，200年后才长成。2007年，丹麦的林业局通知丹麦海军，橡木终于长成了，可以去造船跟英国佬死磕了！只是，大家都不懂，橡木如何加工成航母呢？\n对本书来说，如果你有编程的经验，相关的知识都储备的很好，那当然很好；如果没有编程的经验，也没有储备相关的知识，那也很好。千里之行，始于足下，本书对有无编程经验不做要求。人总要有第一次，理论重要，实战更重要，台上一分钟，台下十年功。\n\n\n3 需要什么学习环境\n小的学习环境是一台电脑，分硬件与软件两个环境。\n硬件环境：一台可以运行的电脑是必不可少的，对硬件的要求不高，只要日常能上网的电脑，都可以用来学习Java编程。简单来说，能打主流游戏的电脑，肯定能学编程，能编程的电脑，可不一定能打游戏。但是，家长/女朋友/老婆并不知道这回事，你可以以学习的名义，配一块4090显卡。\n软件环境：Java是跨平台的，所以对电脑运行的操作系统没有要求，无论Windows、Linux还是苹果的Mac OS都可以。目前Java的稳定版是21，也是本书使用的版本。\n不过呢，当要体验新特征的时候，确实需要更新的版本，到时候再说。Java现在进化很快——这也意味着曾经Java进化很慢——目前Java疯狂的从Kotlin，Swift等一众新生代语言中汲取力量，老黄瓜刷绿漆——装嫩。\n大的环境就是教育了。大家可以想这样一个问题，中国教育与中国足球哪个更有希望呢？\n我觉得，中国教育会更有希望，尤其是计算机专业。原因是，有大量的学生上大学后根本不上课，而是借助大学提供的巨大便利（主要是父母没法盯着了），通过网络自学，然后自谋职业。先用编程把自己的肚子填饱，如果还能学好英文，通过网络给外国的公司打工，如果干的好，就直接移民了，做世界公民不香么？\n不要辜负这个时代啊！\n\n\n4 中英对照的问题\n计算机书有一个不能回避的问题是中英文对照，如何在中文和英文中保持平衡，对我来说是一大难题。在本书中，英文主要可以分为两大类，一类是涉及到的英文人名和英文公司名，别一类是涉及到的编程专业术语。\n对第一类来说，我决定统一保持英文名，像Java之父James Gosling，Sun公司。对第二类来说，就比较不容易权衡了，像Base Class是翻译为“父类”好呢，还是翻译为“基类”好呢？还有Derived Class是翻译为“子类”好呢，还是翻译为“派生类”好呢？这都没有统一的叫法。\n考虑到咱们国家的英语教育已经从小学开始了，能学编程的人，大部分都已经受过相当年限的英语教育，我决定在本书中，大部分类似面向对象，构造函数等不会产生歧义的用中文，少部分有歧义的，使用英语。像一些诸如SDK（Software Development Kit）这样的简写，如果翻译为中文“软件开发工具包”，感觉比SDK更拗口，这时候也使用英文。\n以讹传讹的大家心领神会就好，比如NBA有个球队叫费城76人队，其实人家跟76人没有任何关系，而是纪念1776年美国独立宣言。当然，这个说法也只是众多说法中的一个，但是我们的目的是知道怎么回事，而不是去死扣这些字眼。\n\n\n5 编程的未来\n现在AI横行，编程的未来是属于自然语言编程的。最佳的状态是，你跟AI对话，或者插个脑机接口，AI就把你要做的事情做完了。根本不存在除AI之外的软件了，一切都是AI。但是那一天，鬼知道什么时候能到来。\n在AI完全搞定一切之前，编程语言与程序员尚有生存空间。即使在今天，AI对程序员的帮助依旧巨大。我觉得，哪门编程语言容易重构，就应该学习哪门编程语言。因为，在GitHub Copilot、OpenAI GPT……一众多模态大语言模型的帮助下，我们可以用“自然语言”来让AI帮我们“生成”代码，如果“生成的代码”不满意，就再让AI重新生成一次……\n先学点，容易阅读，容易重构的编程语言，然后等着被自然语言取代吧。\n\n\n6 (严正)声明\n当我看到很多的明星、达人、大V以及显贵用蓝底白字的声明或者严正声明的时候，又是喊律师，又是删帖，又是封号的时候，他们实际上是要开始说谎了。语气越是咄咄逼人，内心越是脆弱不堪。\n但是，没想到吧，我也要声明一下，用来甩锅。\n能力不同，展示的水平就不同。以世界杯为例，一样的球，一样的球场，一样的草坪，对中国队而言，磕磕绊绊的打入32强，已经是莫大的胜利，但对巴西队而言，漂漂亮亮的夺冠才是他们的目标。\n小时候，我有点喜欢足球，看的甲A。真正让我爱上足球的是1998年的法国世界杯，那届世界杯，我认识了罗纳尔多，他展现出来的华丽技术让我惊叹，从此让我沉迷足球，他是我足球的“初恋情人”。\n在这本书里，我要向读者展示我的Java技术，对此我深感畏惧，诚惶诚恐。我尽最大的努力展示我最好的技术给各位。希望这本书让您喜欢上编程，喜欢上Java。\n虽然我希望能展示出巴西队“华丽”的桑巴技术，但是我也深知水平所限，可能展示成了中国队的“磕磕绊绊”。如果看了这本书，您仍然不喜欢编程，那不是编程不好，也不是Java不好，是我展示得不好。\n足球是世界第一大运动，并不因为中国队踢的稀烂而不成为第一大运动。Java是房间里不可忽视的大象，并不因为有个叫栋哥的讲的稀烂而成为小众语言。\n无论如何，愿您早日碰到自己编程的“罗纳尔多”。",
    "crumbs": [
      "Java编程",
      "这本书适合谁？"
    ]
  },
  {
    "objectID": "chapter1.html",
    "href": "chapter1.html",
    "title": "第1章：初识Java",
    "section": "",
    "text": "周公恐惧流言日，\n王莽谦恭下士时。\n假使当年身便死，\n一生真伪有谁知！\n说起这流言，哪个圣贤不挨骂？在编程界，哪个流行的语言不背负一身骂名？Java是被人骂的最多的编程语言之一。毕竟，世界上只有两种编程语言，一种是饱受非议，另一种是无人问津。这一章介绍了Java的历史，从营销角度上来说，Java是第一个被公司营销出来的编程语言。",
    "crumbs": [
      "Java编程",
      "第1章 初始Java"
    ]
  },
  {
    "objectID": "chapter1.html#java登场",
    "href": "chapter1.html#java登场",
    "title": "第1章：初识Java",
    "section": "1.1 Java登场",
    "text": "1.1 Java登场\n1995年2月，John Gage受邀参加了一场会议，在会议上，他要发表一篇题为“科技对教育的作用日益显著”的演讲。在演讲的结尾，他想用一个演示软件来展示目前的高科技，为此，他已经花了一个多月来准备这个演示软件。\n\n\n\n\n\n\nJohn Gage简介\n\n\n\n\n\n\n2004年10月的照片\n\n\n出生于1942年，Sun公司第21号员工，加州大学伯克利分校数学系肄业。在哈佛大学学习以后，开始对Unix感兴趣，后加入Sun公司，成为Sun公司的技术推广大使，营销界的精英人物。\n关于John Gage的介绍，在1996年wired网站上有一篇名为《Power to the People》的文章专门介绍他，链接是：https://www.wired.com/1996/12/esgage\n\n\nJohn Gage演示的软件是用Sun公司尚未透露的编程语言写的，该语言的负责人是James Gosling。因为事关重大，James Gosling不放心让John Gage独自演示，于是，两人决定合作完成，演讲的部分由John Gage来做，展示的部分由James Gosling来做。\n在演讲的结尾，James Gosling出现在台上，他打开一个网页，上面有一个三维的红色分子模型，与当时人们常见的图片不同，这个分子模型可以随着James Gosling的鼠标放大缩小，旋转跳跃，这种新颖的操作方式，在1995年让在座的科技精英都赞叹不已。\n演示所用的技术就是本书的主题：Java编程语言。演示人James Gosling被人称为Java语言之父。",
    "crumbs": [
      "Java编程",
      "第1章 初始Java"
    ]
  },
  {
    "objectID": "chapter1.html#footnotes",
    "href": "chapter1.html#footnotes",
    "title": "第1章：初识Java",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nJavaworld曾经写了一篇文章叫《So why did they decide to call it Java?》，网址：https://www.javaworld.com/article/2077265/so-why-did-they-decide-to-call-it-java-.html↩︎"
  },
  {
    "objectID": "chapter1.html#java的两份文档",
    "href": "chapter1.html#java的两份文档",
    "title": "第1章：初识Java",
    "section": "1.2 Java的两份文档",
    "text": "1.2 Java的两份文档\nJava之父James Gosling的故事想必大家已经耳熟能详，如果不太熟悉的话，推荐到国外计算机历史网站Computer History Museum上观看访谈“James Gosling Oral History”, 这个视频共分为为两部分，分别为 https://youtu.be/Yjq3hZXYp_k 和 https://www.youtu.be/LaJtYHvpa68。在这份长达近七小时的访谈中，James Gosling谈了他本人和Java的方方面面。\n\n\n\n\n\n\nJames Gosling简介\n\n\n\n\n出生于1955年，加拿大人，Java语言创始人。获美国卡内基梅隆大学计算机科学博士学位，1984年加入Sun公司，在此，他研发了Java编程语言。\n\n\n1995年2月，James Gosling发布了一篇只有9页的文档来介绍Java，这篇文档的名字叫《Java: an Overview》。这篇文档简明扼要的指出了当时计算机界存在的问题，并且给出了Java的解决方案。\n随后在1995年10月，James Gosling和Henry McGilton发布了Java第一版白皮书：《The Java Language Environment》。这篇86页的文档详细的介绍了Java的技术细节。\n虽然日后Java发布过多份技术白皮书，但我认为这两份白皮书是Java所有白皮书中最重要的两份。在Java尚未被人所知的年代，James Gosling写的这两份文档，如同明灯一样，指明了Java前进的方向。\n现在25年过去了，在计算机领域，25年让计算机软硬件有了长足的发展，但是这两份文档对Java学习仍然非常有指导意义。\n这两份文档我读过很多次，坦白来讲，在技术领域，能指出问题的人不少，但是能做到抓住问题核心的同时又能提出有效解决方案的人则凤毛麟角。James Gosling做到了，从1995年到今天，Java的份额一路攀升到第一名，我想，在编程语言领域，没有比被程序员喜欢使用更好的赞美。\n接下来，我们一起学习一下这两份文档。看看编程碰到了哪些难题，Java又是如何解决的。",
    "crumbs": [
      "Home",
      "第1章 初始Java"
    ]
  },
  {
    "objectID": "chapter1.html#java面对的问题",
    "href": "chapter1.html#java面对的问题",
    "title": "第1章：初识Java",
    "section": "1.3 Java面对的问题",
    "text": "1.3 Java面对的问题\n起初，James Gosling并没打算开发一门新的编程语言。\n他参与了一个名为Green的项目，这个项目的目标是能让“包括VCR、电话、游戏机、手机、洗碗机等在内的”消费电子产品能够“透明地交互操作”。由于设备类型太多，Gosling的团队碰到了一个棘手的问题，用C++语言支持如此众多的设备，起初可以通过修改C++编译器来解决，随着设备越来越多，最后成了一个“灾难”。于是，James Gosling意识到，是时候做一个新的编程语言了。\n和其它编程语言一样，Java的发展史也是一个找到痛点并解决的历史。在软件发展史上，这种情况屡见不鲜，甚至有了专属自己词汇的描述：“dogfooding”。3\n在上世纪90年代，大部分程序员只能在C和C++语言中选择。每家厂商都有自己独特的设备，有互不兼容的操作系统，再加上互联网的兴起，对设备的要求从单机进化到另一个维度：联网。\n不止C和C++语言，可供选择的语言如Eiffel，SmallTalk，Objective C都没有为互联网的爆发提供足够的支持。在非网络化的情况下，各种设备和程序相互独立。但是一旦接触到互联网，这些相互独立的设备就要面对未知的环境，原本无关紧要的程序漏洞，在互联网环境下可能会是一个灾难。\n所有的一切，让编程越来越困难。\n如何能在减轻程序员负担的同时，还能提高开发软件的质量，是Java自始至终一直在解决的问题。那Java是如何做到的呢？\n\n1.3.1 采用熟悉的语法和熟悉的思想\nJava的设计者认为，要避免程序员花大量的时间来学习一门风格迥异的语言，最直接的方法莫过于借鉴C和C++的语法，毕竟这是当时最流行的语言。这个策略被证明是非常有效的，大量的C++程序员甚至不需要重新学习，就能用自己C++的经验写Java程序。\nSun公司的创始人Bill Joy4对Java的支持功不可没。\n\nBill Joy\n出生于1954年，加州大学伯克利分校硕士，在校期间和朋友一起创办了Sun公司，是公司的联合创始人，在校期间，他是BSD系统的主要设计者，同时还是vi编辑器（本书完全使用该编辑器完成）， C Shell的作者。他是Java创始人James Gosling的上司兼好友，Java项目几乎被取消，都是Bill Joy力排众议，持续支持该项目，最终获得成功。\n\n在语法上，Java不仅继承了C++，还简化了C++，舍弃了一些诸如多重继承，操作符重载比较复杂的特性。同时为了简化编程，Java还增加了诸如内存管理的功能，Java语言可以自动的对内存进行垃圾回收。Michael Feldman曾经这样评价Java：“Java从很多方面来说，就是简化版的C++。”5\n如果你是有一定经验的程序员，同时写过Java与C/C++，就会意识到，其实Java仅仅是在语法的层面上与C/C++相似，实质上，Java的实现更接近Lisp和Smalltalk那样的动态语言。\nJava集百家之长成一家之言，不仅借鉴了C和C++语言，在文档中，Java从不隐瞒这一点，宣称自己的独创性，反而对其它语言的优秀特性大加赞扬，会直言从哪种语言中获得灵感，比如在动态性方面，就从Objective-C借鉴了很多想法。在本书中，我会尽量对这些特征一一考证。\n本书会有大量的章节讨论Java的语法和面向对象的问题，包括第5章和第6章的基本操作符和基本语法，第3章、第9章、第10章、第11章等章节都是讨论面向对象的问题。\n\n\n1.3.2 改善可移植性\n取得成功的编程语言，一定要兼顾这三个方面：运行速度、可移植性与安全性。同时满足运行速度与可移植性的语言就很少，更不要说还要兼顾安全性了。一般来说，运行速度快的语言，可移植性不高，可移植性高的语言，又难以做到兼容性。\n用C语言写的Unix操作系统也被广泛的宣传具有强大的可移植性，但是这种“可移植性”是建立在对每一种机器要修改的基础上，比如有的机器int是16位的，有的机器是32位的，还是要根据不同的CPU进行代码的修改，然后才能做到可移植性。6\nJava的出现，真正实现了可移植性。在Java里，所有的基本数据类型的大小都是规定好的，不会随着CPU的变化而变化。比如说，在Java中，所有的int意味32位，所有的float都是实现的IEEE 754，这极大的方便了程序员的工作。\n但是这并不是没有代价的，C语言为了可移植性牺牲了语言的功能，Java为了可移植性牺牲了部分运行速度。\n在本书的第4章，我们会来详细讨论可移植性与基本数据类型这个问题。\n\n\n1.3.3 采用解释执行\nJava语言是一种解释型语言，只要将Java源程序编译成字节码，这些字节码就可以直接在Java虚拟机上运行。相比于编译，链接是一个要轻量级的过程，因此开发的过程要更快一些。7\n毕竟25年过去了，Java在这方面有了长足的进步，从某种意义上来说，现在的Java已经不完全是James Gosling在1995年的规划。尤其在Java是一个纯解释语言这一点上，发生了重大的变化 。现在的Java早已经是兼具编译型和解释型语言的特点。\n关于这方面内容，我会在第二章，和大家详细的研究Java虚拟机，Java编译器各自的作用。在1995年的文档里，James Gosling给出了一个数据，在一台SS10电脑上，用解释器运行Java，每秒钟可以调用30万次函数，这个数据和C/C++写的软件没有明显的差距。Java虚拟机进化了多年，现在人们已经对Java的性能没有太多质疑，有很多的数据支持显示，Java是运行最快的语言之一。\n目前来说，Java的运行速度已经不再是问题，著名的游戏公司ID Software已经开源了其第一人称射击游戏Quake2的源代码，随后，有人将此引擎移植为Java项目,这个项目名为Jake2，完整的代码可以在github网站上找到。具体的链接如下: https://github.com/demoth/jake2 。如果Java的性能足够满足第一人称射击游戏的要求，那么肯定可以满足商业程序的要求。\nJava代码的执行速度是不稳定的，高度依赖于运行平台与Java虚拟机。即使是同样一份代码，不做任何改进，在比较新的Java虚拟机上基本上运行速度都会有所提升。\n最初的Java采用解释执行的原因是Java非常的务实，对性能的态度一贯是只要能提高开发效率，就可以牺牲原始性能。也正是因为这个原因，只有到了近些年，诸如HotSpot之类 Java虚拟机日益成熟后，高性能计算领域才开始采用Java进行开发。\n在设计语言和平台的时候，经常对需要的功能与运行效率之间进行平衡。如果要更“接近机器”，那么就有可能“降低开发效率”。C++的作者一直推崇他的“零成本原则”，这条原则的内容如下： C++遵从零成本原则：不需要为用不到的功能付出代价。再进一步，你要用的东西，性能已经达到极致了，就算再优化也不会有更好的性能了。\n这个原则听起来是非常好的，但是对绝大多数人没什么用。因为对绝大多数来来说，自己没法掌控软件运行所依赖的底层机制，都是要借用别人写的操作系统来运行自己的代码。如果还要追求零成本的运行代价，开发人员就要付出巨大的认知代价，要搞清楚计算机是如何运行的，并不容易。\n像C/C++所采用的跨平台方法是预先编译（Ahead of Time, AOT），对不同的平台要分别编译，势必要详细了解那种平台的机器代码。这个原则是为像C++作者这种级别的绝顶高手量身定做的，这里的零成本隐藏了太多东西。高手能实现的零成本解决方案，比如人家很容易实现一个解释器，对其他人的成本可能就太高了。\nJava不认可零成本原则，Java做出的取舍是：借鉴C/C++的预先编译，同时又不放弃解释执行。通过这种方法，可以降低写软件的难度。"
  },
  {
    "objectID": "chapter1.html#java面对的问题以及解决方案",
    "href": "chapter1.html#java面对的问题以及解决方案",
    "title": "第1章：初识Java",
    "section": "1.3 Java面对的问题以及解决方案",
    "text": "1.3 Java面对的问题以及解决方案\n起初，James Gosling并没打算开发一门新的编程语言。\n他参与了一个名为Green的项目，这个项目的目标是能让“包括VCR、电话、游戏机、手机、洗碗机等在内的”消费电子产品能够“透明地交互操作”。由于设备类型太多，Gosling的团队碰到了一个棘手的问题，用C++语言支持如此众多的设备，起初可以通过修改C++编译器来解决，随着设备越来越多，最后成了一个“灾难”。于是，James Gosling意识到，是时候做一个新的编程语言了。\n和其它编程语言一样，Java的发展史也是一个找到痛点并解决的历史。在软件发展史上，这种情况屡见不鲜，甚至有了专属自己词汇的描述：“dogfooding”。\n\n\n\n\n\n\n什么叫Dogfooding?\n\n\n\nDogfooding这个词语来自于“Eating your own dog food”，可以翻译为“吃自己的狗粮”。\n在IT业界这句俚语可能最早是于1988年开始使用的。当时微软公司的高级主管保罗·马瑞兹曾写过一封题为“Eating our own Dogfood”（吃我们自家的狗粮）的邮件，在邮件中他向微软局域网管理工具项目的测试主管布莱恩·瓦伦蒂尼提出“提高内部使用自家产品比重”的挑战。\n从此以后，这一俚语就传播开来了。\n\n\n在上世纪90年代，大部分程序员只能在C和C++语言中选择。每家厂商都有自己独特的设备，有互不兼容的操作系统，再加上互联网的兴起，对设备的要求从单机进化到另一个维度：联网。\n不止C和C++语言，可供选择的语言如Eiffel，SmallTalk，Objective C都没有为互联网的爆发提供足够的支持。在非网络化的情况下，各种设备和程序相互独立。但是一旦接触到互联网，这些相互独立的设备就要面对未知的环境，原本无关紧要的程序漏洞，在互联网环境下可能会是一个灾难。\n所有的一切，让编程越来越困难。\n如何能在减轻程序员负担的同时，还能提高开发软件的质量，是Java自始至终一直在解决的问题。那Java是如何做到的呢？\n\n1.3.1 采用熟悉的语法和熟悉的思想\nJava的设计者认为，要避免程序员花大量的时间来学习一门风格迥异的语言，最直接的方法莫过于借鉴C和C++的语法，毕竟这是当时最流行的语言。这个策略被证明是非常有效的，大量的C++程序员甚至不需要重新学习，就能用自己C++的经验写Java程序。\nSun公司的创始人Bill Joy对Java的支持功不可没。\n\n\n\n\n\n\nBill Joy简介\n\n\n\n\n出生于1954年，加州大学伯克利分校硕士，在校期间和朋友一起创办了Sun公司，是公司的联合创始人。\n在校期间，他是BSD系统的主要设计者，同时还是vi编辑器（本书完全使用该编辑器完成，所以，我经常推荐别人用Vim编辑器，一是为了装逼，二确实挺好用的 :）， 他还是C Shell的作者。\n\n\n\n那么，我现在推荐用哪个编辑器？看上图！\n\n\n他是Java创始人James Gosling的上司兼好友，Java项目几乎被取消，都是Bill Joy力排众议，持续支持该项目，最终获得成功。\nBill Joy的故事可以参考《Unix Review》杂志在1984年对他的采访，名字是《Interview with Bill Joy》，在访谈中，有关于vi编辑器，Unix等有趣的故事。在线网址是：https://web.archive.org/web/20120210184000/http://web.cecs.pdx.edu/~kirkenda/joy84.html\n\n\n在语法上，Java不仅继承了C++，还简化了C++，舍弃了一些诸如多重继承，操作符重载比较复杂的特性。同时为了简化编程，Java还增加了诸如内存管理的功能，Java语言可以自动的对内存进行垃圾回收。Michael Feldman曾经这样评价Java：“Java从很多方面来说，就是简化版的C++。”\n\n\n\n\n\n\nTip\n\n\n\n他评价的原文是：Java is, in many ways，C++--。\n\n\n如果你是有一定经验的程序员，同时写过Java与C/C++，就会意识到，其实Java仅仅是在语法的层面上与C/C++相似，实质上，Java的实现更接近Lisp和Smalltalk那样的动态语言。\nJava集百家之长成一家之言，不仅借鉴了C和C++语言，在文档中，Java从不隐瞒这一点，宣称自己的独创性，反而对其它语言的优秀特性大加赞扬，会直言从哪种语言中获得灵感，比如在动态性方面，就从Objective-C借鉴了很多想法。在本书中，我会尽量对这些特征一一考证。\n本书会有大量的章节讨论Java的语法和面向对象的问题，包括第5章和第6章的基本操作符和基本语法，第3章、第9章、第10章、第11章等章节都是讨论面向对象的问题。\n\n\n1.3.2 改善可移植性\n取得成功的编程语言，一定要兼顾这三个方面：运行速度、可移植性与安全性。同时满足运行速度与可移植性的语言就很少，更不要说还要兼顾安全性了。一般来说，运行速度快的语言，可移植性不高，可移植性高的语言，又难以做到兼容性。\n用C语言写的Unix操作系统也被广泛的宣传具有强大的可移植性，但是这种“可移植性”是建立在对每一种机器要修改的基础上，比如有的机器int是16位的，有的机器是32位的，还是要根据不同的CPU进行代码的修改，然后才能做到可移植性。\n\n\n\n\n\n\nUnix痛恨者手册\n\n\n\n在网上有一本神书叫《Unix痛恨者手册》，是一群Unix的讨厌者写的书。\n书写完以后，请C语言与Unix系统的开发者丹尼斯·里奇写序言，丹尼斯·里奇也不客气，痛骂了本书，这本书把这个痛骂自己的话原封不动的当了序言。\n网上有本书的中文翻译版，如果你找不到，可以到我的个人网站上去下载: https://liuyandong.com 或者到https://xueban.app这个社区下载。\n\n\nJava的出现，真正实现了可移植性。在Java里，所有的基本数据类型的大小都是规定好的，不会随着CPU的变化而变化。比如说，在Java中，所有的int意味32位，所有的float都是实现的IEEE 754，这极大的方便了程序员的工作。\n但是这并不是没有代价的，C语言为了可移植性牺牲了语言的功能，Java为了可移植性牺牲了部分运行速度。\n在本书的第4章，我们会来详细讨论可移植性与基本数据类型这个问题。\n\n\n1.3.3 采用解释执行\nJava语言是一种解释型语言，只要将Java源程序编译成字节码，这些字节码就可以直接在Java虚拟机上运行。相比于编译，链接是一个要轻量级的过程，因此开发的过程要更快一些。 你可以想象一下现在为什么大家都喜欢用“热更新”的方式来开发App，因为更轻量级，方便。\n\n\n\n\n\n\nTip\n\n\n\n因为这份文件是历史文档，Java 1.0的时候，只提供了一个纯解释的运行环境，现在已经有所改变。\n等一会我们再来讨论Java到底是编译执行还是解释执行这件事。\n\n\n毕竟25年过去了，Java在这方面有了长足的进步，从某种意义上来说，现在的Java已经不完全是James Gosling在1995年的规划。尤其在Java是一个纯解释语言这一点上，发生了重大的变化 。现在的Java早已经是兼具编译型和解释型语言的特点。\n关于这方面内容，我会在第二章，和大家详细的研究Java虚拟机，Java编译器各自的作用。在1995年的文档里，James Gosling给出了一个数据，在一台SS10电脑上，用解释器运行Java，每秒钟可以调用30万次函数，这个数据和C/C++写的软件没有明显的差距。Java虚拟机进化了多年，现在人们已经对Java的性能没有太多质疑，有很多的数据支持显示，Java是运行最快的语言之一。\n\n\n\n\n\n\n讽刺Java慢的段子\n\n\n\nJava，C，C++，汇编……在一艘船上，船漏水了，为了保证其它人的安全，决定扔两个人下去。规则是讲笑话，只要有一个人不笑，就把讲笑话的人扔下去。\n汇编是讲笑话的高手，他讲了一个笑话，把其它人都笑弯了腰，只有Java没笑，按规则，汇编被扔了下去。第二个轮到C语言讲了，C语言还没开口，Java就笑弯了腰，众人不解，问Java笑什么？\nJava回答：“刚才汇编的笑话太好笑了！”\n\n\n目前来说，Java的运行速度已经不再是问题，著名的游戏公司ID Software已经开源了其第一人称射击游戏Quake2的源代码，随后，有人将此引擎移植为Java项目,这个项目名为Jake2，完整的代码可以在github网站上找到。具体的链接如下: https://github.com/demoth/jake2 。如果Java的性能足够满足第一人称射击游戏的要求，那么肯定可以满足商业程序的要求。\nJava代码的执行速度是不稳定的，高度依赖于运行平台与Java虚拟机。即使是同样一份代码，不做任何改进，在比较新的Java虚拟机上基本上运行速度都会有所提升。\n最初的Java采用解释执行的原因是Java非常的务实，对性能的态度一贯是只要能提高开发效率，就可以牺牲原始性能。也正是因为这个原因，只有到了近些年，诸如HotSpot之类 Java虚拟机日益成熟后，高性能计算领域才开始采用Java进行开发。\n在设计语言和平台的时候，经常对需要的功能与运行效率之间进行平衡。如果要更“接近机器”，那么就有可能“降低开发效率”。C++的作者一直推崇他的“零成本原则”，这条原则的内容如下： C++遵从零成本原则：不需要为用不到的功能付出代价。再进一步，你要用的东西，性能已经达到极致了，就算再优化也不会有更好的性能了。\n这个原则听起来是非常好的，但是对绝大多数人没什么用。因为对绝大多数来来说，自己没法掌控软件运行所依赖的底层机制，都是要借用别人写的操作系统来运行自己的代码。如果还要追求零成本的运行代价，开发人员就要付出巨大的认知代价，要搞清楚计算机是如何运行的，并不容易。\n像C/C++所采用的跨平台方法是预先编译（Ahead of Time, AOT），对不同的平台要分别编译，势必要详细了解那种平台的机器代码。这个原则是为像C++作者这种级别的绝顶高手量身定做的，这里的零成本隐藏了太多东西。高手能实现的零成本解决方案，比如人家很容易实现一个解释器，对其他人的成本可能就太高了。\nJava不认可零成本原则，Java做出的取舍是：借鉴C/C++的预先编译，同时又不放弃解释执行。通过这种方法，可以降低写软件的难度。",
    "crumbs": [
      "Java编程",
      "第1章 初始Java"
    ]
  },
  {
    "objectID": "chapter1.html#终身仁慈独裁者",
    "href": "chapter1.html#终身仁慈独裁者",
    "title": "第1章：初识Java",
    "section": "3.1 终身仁慈独裁者",
    "text": "3.1 终身仁慈独裁者\nJava的创始人James Gosling被称之为BDFL。\nBDFL的意思是终身仁独裁者BDFL（Benevolent Dictator For Life）是极少数软件开发者能拥有的头衔，一般是某个语言、某个项目的创始人。当软件社区出现争议并且无法和平解决的时候，要有一个最终的话事人来解决纷争。其它耳熟能详的BDFL有Linux的开发者Linus、Python的开发者吉多·范罗苏姆、Perl的作者Larry Wall、LLVM的设计者Chris Lattner等等。\n能够当BDFL的人，要有很强的领袖气质，能以德服人。而且，在编程领域中，独裁者是会“体面”的离开的。\n不止Java，像Python，JavaScript语言，都经历了开始主要由一个人主导，后来一个委员会主导，到最后，语言的创始人离开。2018年7月12日，Python 创始人 Guido van Rossum发邮件决定离开Python决策层，不再领导Python语言的开发。有兴趣的读者，可以找来那封信读一下。",
    "crumbs": [
      "Home",
      "第1章 初始Java"
    ]
  },
  {
    "objectID": "chapter1.html#java的名字是谁起的",
    "href": "chapter1.html#java的名字是谁起的",
    "title": "第1章：初识Java",
    "section": "3.2 Java的名字是谁起的？",
    "text": "3.2 Java的名字是谁起的？\n以目前能找到的资料，Java项目最开始的时候，名字并不是Java，而是Oak。之所以叫Oak，是因为在James Gosling的办公室外有一棵橡树。当时有一家已经存在的公司叫Oak Technologies，只能改名。\n\n\n\n\n\n\n为什么要叫Java，是找算命先生算过么？\n\n\n\nJavaworld曾经写了一篇文章叫《So why did they decide to call it Java?》，网址：https://www.javaworld.com/article/2077265/so-why-did-they-decide-to-call-it-java-.html\n原来起名的时候有几个候选，分别是Silk、Lyric、Pepper、Java。当时的产品经理Kim Polese提出了这个名字。",
    "crumbs": [
      "Java编程",
      "第1章 初始Java"
    ]
  },
  {
    "objectID": "chapter1.html#java的现状怎么样",
    "href": "chapter1.html#java的现状怎么样",
    "title": "第1章：初识Java",
    "section": "3.4 Java的现状怎么样?",
    "text": "3.4 Java的现状怎么样?\n无论是从找工作还是从学习编程的角度，Java都是一门不可忽视的语言。\n大家只要打开搜索引擎或者GitHub网站，查找一下语言的排名，或者在找工作的网站上看一下，就知道Java始终是最热门语言之一。写这本书的时候，我在找工作的网站dice.com上使用关键字Java时行了搜索，有11,153个工作，用Python当关键字，有6,395个工作，用JavaScript，则有8,634个工作。这些结果应该相对直观的反应了市场需求。如果你的目标是学好英语，找外国的远程工作，Java还是不错的。\n从学术和技术角度来看，现在越来越多语言都是基于Java实现，运行在Java虚拟机之上。比如Groovy、JRuby、Scala、Jython、Clojure这些语言，都是如此，只要能运行于Java虚拟机，就是站在巨人的肩膀上，有了与生俱来的跨平台特征。从这个角度来看，学会Java，能更深入的了解这些语言。\n业界有一句名言：“没有人因为选择Java而被解雇。”这句话的潜台词是：Java的背后有大公司的支持，这意味着可以得到某种保证，保证Java能得到积极维护和开发，具有繁荣的生态系统和社区，并已经Java已经在大型业务环境经受了考验。企业就喜欢这样的技术，可以减少技术选型的风险。这也是Java长期排名前茅的原因。\n\n\n\n\n\n\n工字不出头，出头入黄土\n\n\n\n我还是想扯一点闲篇。我老家有句叫“工字不出头，出头入黄土”。这里的“工”有很多的解释，可能是“工人”，可能是“工资”，可能是“工程师”，可能是“打工”……因为你在学习Java，可能梦想是当个“软件工程师”，好吧，这也算“工”的一种。\n亲爱的读者，靠这个“工”，是很难出头的，包括“打工”的“软件工程师”。本书的作者——也就是我，寒窗二十年，打工十余载，一事无成——已经证明了这一点，证明了我老家人的智慧，多么痛的领悟啊！不要试图靠“工”改命。\n那靠什么？我还不知道，如果我知道了，我会在这里更新的。也希望你能告诉我，我的电子邮件是liuyandong@gmail.com。感恩贵人的不吝赐教。",
    "crumbs": [
      "Java编程",
      "第1章 初始Java"
    ]
  },
  {
    "objectID": "chapter1.html#james-gosling如何回答相比于c语言java不够自由",
    "href": "chapter1.html#james-gosling如何回答相比于c语言java不够自由",
    "title": "第1章：初识Java",
    "section": "3.3 James Gosling如何回答相比于C语言，Java不够自由？",
    "text": "3.3 James Gosling如何回答相比于C语言，Java不够自由？\nJames Gosling对此的解释是：“对Java来说，规矩有很多，一旦你适应了规矩，那么Java将是一种自由的语言。”他还以飞机为例打了个比方，在螺旋桨时代，飞机非常的自由，飞行员可以打开窗户，呼吸新鲜的空气，可以通过肉眼来观察方向。到了喷气式飞机时代，飞机的窗户是不能打开的，如果你打开，在3马赫的速度下，飞行员的脑袋将会被吹走。\n最后，他总结说：“如果你想进一步让自己自由，就要放弃一些看起来是自由的东西。”\n我不知道为什么，看到James Golsing讲这句话的时候，我脑海中想到的是阿尔贝·加缪写的《西西弗神话》，在一个看似没有意义的世界中，我们应该如何找到意义和应对编程、甚至生命的荒诞感。在加缪的哲学中，自由不仅仅是选择的能力，而是承担选择后果的责任。\n这一点，倒是与James Gosling有相通之处。",
    "crumbs": [
      "Java编程",
      "第1章 初始Java"
    ]
  },
  {
    "objectID": "chapter2.html",
    "href": "chapter2.html",
    "title": "第2章 第一行代码",
    "section": "",
    "text": "编程难，纹身大哥胆寒！\n枪林弹雨何所惧，更喜狱友菊花残。\n垂死病中惊坐起，程序崩的没道理。\n为什么会有这首打油诗呢？因为我看到一个新闻，讲的是地球的另一边，美国，有https://thelastmile.org这样一个 项目，如果你犯了事，被关进了监狱。监狱里就会培训你：编程！\n听说，这大大降低了犯罪率，因为很多惯犯出狱之后，一想到再次入狱，要去学编程，就放弃了作案的想法，那可太痛苦了，宁可死刑也不愿意去监狱学编程！\n本章的主要目的是把开发环境给跑起来，用Hello World肯定学不到什么东西，但是至少能检测开发环境有没有跑起来。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#用什么工具来输入代码",
    "href": "chapter2.html#用什么工具来输入代码",
    "title": "第2章 第一行代码",
    "section": "1.1 用什么工具来输入代码？",
    "text": "1.1 用什么工具来输入代码？\n简单来说，用VSCode或者IntelliJ IDEA，前者是一个编辑器（虽说是编辑器，但是比十年前的IDE，比如Eclipse，NetBeans的功能强太多了），后者是一个IDE。说实在的，不管这两个你用哪个，都已经是非常强大了，强大到无论你用哪个，都可以通过菜单把代码运行起来。\n\n\n\n\n\n\nEclipse VS NetBeans是当年争锋的两大IDE\n\n\n\nEclipse最初是由IBM开发的内部工具，在2001年发布为开源项目。Eclipse的设计师是 Erich Gamma，同时他也是JUnit的作者。Eclipse的精髓是插件，但是Eclipse的插件可以进入主进程，一些“水平很一般”的程序员，可能就把主进程给写坏了。\n后来VS Code就吸取了经验，等等，为什么VS Code能吸取经验呢？因为VS Code是Erich Gamma跳槽到微软做出来的。\n至于NetBeans，也是一个IDE。哎，本书的作者——就是我——曾经在Sun公司里去高校以及各种技术大会，比如Intel开发者大会，推广过Solaris和NetBeans，推广真的好难，背着宣传单，背着光盘，还得送人家巧克力。人家还不一定用，只是把光盘上送的巧克力吃了，出门就把光盘扔了。\n\n\n我就不多介绍什么是VSCode和IntelliJ IDEA了，问问ChatGPT吧。如果开发Java的话，项目一旦变大，IntelliJ IDEA是更好的选择，这家捷克开发的软件，有收费版，也有免费的社区版，用免费的就足够了。\n只需要点一下，代码就跑起来了，就跟自动档汽车一样，“傻瓜”都会开。\n无论你选择哪个，我都建议你安装一些AI插件，这些AI插件可以自动帮你补全所有的代码。插件实在太多了，也没人给我广告费，所以我就不推荐了。我用的是GitHub的Copilot，但是这个每个月要收10美元。如果没人给你这个钱，就用免费的吧，功能大差不差，尤其是对初学者，都是用最简单的功能，没差别。\n\n\n\n\n\n\n推荐用哪个工具？\n\n\n\n没有什么好推荐的，我做事的原则是：大事看原则，小事讲风格。\n用哪个工具，缩进用空格还是用tab，显然都是小事，你有自己的风格就好。又不是什么家国大事，婚姻大事，如果在这些大事上有冲突，赶紧跑路，最好打车跑路。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#输入的时候需要注意什么",
    "href": "chapter2.html#输入的时候需要注意什么",
    "title": "第2章 第一行代码",
    "section": "1.2 输入的时候需要注意什么？",
    "text": "1.2 输入的时候需要注意什么？\n编程语言是“语言”的一种，而且是“最死板”的那一类。错一点，也不给你运行。所以，对初学者，有以下需要注意的地方：\n\n1.2.1 源代码的文件名要与类名严格一致\n如果你是初学者，可能会好奇，什么叫类名？没关系，类名就是上面代码中 class 后面跟着的HelloWorld。java的源文件后缀名为.java。所以，源代码的文件名为HelloWorld.java。\n\n\n1.2.2 要注意全角与半角符号\n在源代码中有分号、逗号、花括号……这些都应该用英文的半角字符，而不能用中文的全角字符。在英文中，这些符号都是半角——在排版时占据一个字符的宽度。而在中文中，这些符号都是全角——在排版时占据两个字符的宽度。\n我当年初学的时候，在这上面可吃了大亏了。\n\n\n1.2.3 可以用AI补全\n要是搁在以前，我都是建议别人手打一遍代码，受受苦，但是现在，真是用不着了。AI目前这么强大，现在你不让他干活，到时候它强大到足够奴役人类的时候，可不一定会让你清闲哦。早享受总是对的。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#用什么工具来让源文件跑起来",
    "href": "chapter2.html#用什么工具来让源文件跑起来",
    "title": "第2章 Hello World",
    "section": "1.3 用什么工具来让源文件跑起来？",
    "text": "1.3 用什么工具来让源文件跑起来？\n用的工具是JDK，全称为Java Development Kit（JDK），这是Sun针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK，即使后来Sun公司被Oracle收购了，也叫JDK，只是叫Oracle JDK了。\n至于如何安装JDK，我就不废话了，请打开ChatGPT这类大语言模型，输入类似“ 如何在Windows上配置Java开发环境？”大语言模型处理这种事情，特别拿手。\n如果你使用的是IntelliJ IDEA，可能你连装JDK的机会都没有，IntelliJ IDEA当检测到你的电脑没有JDK的时候，会使用自己的JetBrains Runtime，这是一个基于OpenJDK的修改版本，作为运行环境。\n无论是借助大AI来帮助你完成的开发环境配置，还是IntelliJ IDEA自动安装的，最终，都会安装几个软件，最重要的有两个，一个叫javac，另一个叫java。\njavac的是java语言的编译器，其作用是将java源代码（就是前面那个HelloWorld.java）编译成字节码，如果你用命令行的话，命令如下：\njavac HelloWorld.java\n这条命令执行之后，会生成字节码文件（你会发现执行完以上的命令之后，在存放HelloWorld.java的目录下，多了一个叫HelloWorld.class的文件）。然后，再使用java"
  },
  {
    "objectID": "chapter2.html#如何让源文件跑起来",
    "href": "chapter2.html#如何让源文件跑起来",
    "title": "第2章 第一行代码",
    "section": "1.3 如何让源文件跑起来？",
    "text": "1.3 如何让源文件跑起来？\n用的工具是JDK，全称为Java Development Kit（JDK），这是Sun针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。自从Java推出以来，JDK已经成为使用最广泛的Java SDK，即使后来Sun公司被Oracle收购了，也叫JDK，只是叫Oracle JDK了。\n至于如何安装JDK，我就不废话了，请打开ChatGPT这类大语言模型，输入类似“ 如何在Windows上配置Java开发环境？”大语言模型处理这种事情，特别拿手。\n如果你使用的是IntelliJ IDEA，可能你连装JDK的机会都没有，IntelliJ IDEA当检测到你的电脑没有JDK的时候，会使用自己的JetBrains Runtime，这是一个基于OpenJDK的修改版本，作为运行环境。\n无论是借助大AI来帮助你完成的开发环境配置，还是IntelliJ IDEA自动安装的，最终，都会安装几个软件，最重要的有两个，一个叫javac，另一个叫java。\njavac的是java语言的编译器，其作用是将java源代码（就是前面那个HelloWorld.java）编译成字节码，如果你用命令行的话，命令如下：\njavac HelloWorld.java\n这条命令执行之后，会生成字节码文件（你会发现执行完以上的命令之后，在存放HelloWorld.java的目录下，多了一个叫HelloWorld.class的文件）。然后，再使用java来运行刚刚生成的字节码，命令如下：\njava HelloWorld\n这里需要注意的是，不需要HelloWorld.class这里的.class后缀。\n但是现在没人还这样手工来处理了，都是使用VS Code或者IntelliJ IDEA，这些工具已经足够智能，完全自动的处理javac与java的执行过程。点个按钮，直接出结果。这当然简化了工作，但是也会让人搞不清楚到底发生了什么事。\n各有利弊吧。希望你在VS Code上，或者IntelliJ IDEA上看到了“Hello World”这两个单词。如果没有，恭喜你，你碰到bug了。看下一小节。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#footnotes",
    "href": "chapter2.html#footnotes",
    "title": "第2章 Hello World",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nEclipse最初是由IBM开发的内部工具，在2001年发布为开源项目。Eclipse的设计师是 Erich Gamma，同时他也是JUnit的作者。Eclipse的精髓是插件，但是Eclipse的插件可以进入主进程，一些“水平很一般”的程序员，可能就把主进程给写坏了。后来VS Code就吸取了经验，等等，为什么VS Code能吸取经验呢？因为VS Code也是Erich Gamma跳槽到微软做出来的。↩︎\n至于NetBeans，也是一个IDE。哎，本书的作者——就是我——曾经在Sun公司里去高校以及各种技术大会，比如Intel开发者大会，推广过Solaris和NetBeans，推广真的好难，背着宣传单，背着光盘，还得送人家巧克力。人家还不一定用，只是把光盘上送的巧克力吃了，出门就把光盘扔了。↩︎"
  },
  {
    "objectID": "chapter2.html#碰到bug了怎么办",
    "href": "chapter2.html#碰到bug了怎么办",
    "title": "第2章 第一行代码",
    "section": "1.4 碰到bug了怎么办？",
    "text": "1.4 碰到bug了怎么办？\n如果你认为确实没有任何问题，但是就是不运行，哥们，第一件事情：重启（先重启开发环境，再重启电脑）。可能会有其它同事说你，你TMD就是会重启，这时候，如果你觉得有必要跟他争论，就以下面的理论为基础进行人身攻击。\n图灵奖得主Jim Gray写的论文，名字叫《Why Do Computers Stop and What Can Be Done About It》，我把这篇论文放在我的社区xueban.app里。在这篇论文里，Jim Gray认为，bug为两种，一种是玻尔bug，另一种是海森堡bug。\n\n\n\n\n\n\nJim Gray简介\n\n\n\n\nJim Gray是第三位因推动数据库技术而获得图灵奖的人，在计算机方面有非常多贡献。他爱好冒险，在2007年1月28日，他驾驶着自己40英尺的船，消失在茫茫大海，至今杳无音讯。5年后的2012年1月28日，Jim Gray在法律上被宣告去世。\n我平时还有个爱好是录podcast，名字叫“软件那些事儿”，我录了快500期电台了。有一个系列叫图灵奖得主介绍，就介绍每一年图灵奖得主的信息，如果你有兴趣，可以搜来听听，或者到liuyandong.com上看文字版。\n\n\n按照Jim Gray的分类，玻尔bug是能通过测试，容易复现，也比较容易解决的bug。海森堡bug是不确定的，不容易复现，不容易解决的bug。正如两位科学家所研究的理论一样，一个如原子结构般确定，一个如电子行为般不确定。\n如果重启能解决，那我们碰到的就是玻尔bug。\n如果重启还没有解决问题，一般来说，把报告的错误信息放到搜索引擎里，是个好办法。初学者，碰不到什么新鲜bug，99.9999%的情况下，咱们碰到的bug都是别人碰到，并且解决过的。\n但是也不否认你确实碰到了别人没有碰到的bug，虽然机率确实很低，而且是用HelloWorld这种代码碰到的，概率就更低了。\n不过，凡事不能太绝对，比如，在Java的历史上，就有一个至今都没修复的bug，这个bug是初学者就能碰到的。有兴趣的读者可以到Java的bug系统上去看看，网址是：https://bugs.java.com/bugdatabase/index.jsp 输入这个bug的编号：4252539.\n按照Java语言的规则，main函数必须被声明为public，但是软件难免会出现bug。在Java 1.4之前的一些版本里，public不被声明为public也可以运行。这个bug从来没有被修复过，主要原因是如果修复了，可能会导致其它不可预知的结果。不少bug就是会被置之不理的。\n\n\n\n\n\n\n苹果手机里也有“没人理”的bug\n\n\n\n如果大家用iOS 1582 calendar作为关键字来搜索，会找到这个bug的详细介绍。\n简单来说，在1582年，人类的日历从儒略历换成了格里历。这就导致在1582年的2月份出现了2月31日。iOS系统没有恰当的处理这个bug，以后不知道会不会处理，但是谁会在意1582年的日历呢？\n\n\n同样，bug足够出名，还会成为feature。（你足够出名，写的错别字就会成为通假字，人是一种贱嗖嗖的生物，欺软怕硬。鲁迅写就是通假字，你写就是错别字被都是扣1分）。\n在软件史上，有很多类似的情况，bug成了feature，将错就错。比如Unix上的creat，本来应该是create，但是少写了一个e，后来所有的Unix变种都将错就错的少写了一个e。后来有人问到Unix的作者Ken Thompson如果你要重要设计Unix，你会做哪些改变，他回答说把creat写成create。这个故事来源：https://en.wikiquote.org/wiki/Ken_Thompson",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#sun的虚拟机",
    "href": "chapter2.html#sun的虚拟机",
    "title": "第2章 第一行代码",
    "section": "2.1 Sun的虚拟机",
    "text": "2.1 Sun的虚拟机\n1996年，Sun发布Java语言的同时，还发布了世界上第一个Java虚拟机。这个虚拟机之所以重要，是因为是世界上第一个JVM。缺点也很明显，这个JVM的执行效率非常差。\n随后，Sun公司开始对Java虚拟机进行改进。改进的成果是一款只可以运行在Solaris上的JVM，名叫Exact VM。如果大家用Exact VM在Oracle的官网上搜索，仍然可以找到一些信息。大部分信息都是介绍Exact VM和HotSpot在编译时如何设置参数。\n但是Sun没有再继续推广这款名为Exact VM的虚拟机，原因是一个更为先进的虚拟机出现了，这个虚拟机也是目前最为流行的Java虚拟机之一，名字就叫HotSpot。\nHotSpot并不是Sun公司做的，而是一家叫Longview Technologies的产品，这家公司的创始人，一个叫Urs Hölzle，一个叫Lars Bak，两人从Sun离职后创业。为了重新获得这两个员工和他们的产品，Sun收购了这家公司。\n该产品原本是针对SmallTalk语言做的虚拟机，被收购以后重新设计，转而支持Java语言，跟随Java 1.2的同时发布。\nJava的1.2版本，有3个JVM，一个是Sun公司第一版的虚拟机，一个是Solaris上的Exact VM，还有一个就是HotSpot。默认的JVM是最慢的那一个，直到1.3版以后，才将默认的虚拟机换成HotSpot。\n在早期，只有Sun公司有JVM，其它公司没有“版权”来染指Java。直到1998年，Sun公司成立了JCP（Java Community Process）组织，这个组织希望让越来越多的公司参与进来，大家都分一杯羹。当然了，Sun公司肯定是想做分羹的人，大家做Java可以，但是要通过TCK（Technology Compatibility Kit），翻译成中文叫技术兼容性测试。\n在TCK的约束下，不少公司通过了TCK，也号称自己的虚拟机叫JVM。在这个背景下，有很多公司推出了自己的Java虚拟机。最著名的厂商有IBM、BEA、Microsoft和Apache。\n\n\n\n\n\n\nIBM的J9虚拟机\n\n\n\nIBM官网上介绍，这款JVM最早是由IBM Ottawa实验室一个SmallTalk的虚拟机扩展来的。\n那时候，这个虚拟机有一个bug是因为8k值定义错误引起，工程师们花了很长时间终于发现并解决了这个错误，此后这个版本的虚拟机就被称为K8了。\n后来出现的支持Java这个版本的虚拟机就被称为J9了。\n\n\n与Sun公司收购HotSpot类似，IBM的J9也是收购的。1996年，IBM收购了一家叫OTI（Object Technology International）的公司，该公司有虚拟机产品。更巧合的是，这个产品最初也是为SmallTalk语言设计的虚拟机，后来在Java流行以后，才改为支持Java虚拟机。\n2017年，J9变成了IBM主导的Eclipse组织的一个项目，名字已经改成了Eclipse OpenJ9。现在建立在Eclipse开放运行时项目（OMR）之上，IBM的专有项目大部分基于此，它完全兼容Java认证。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#ibm的j9虚拟机",
    "href": "chapter2.html#ibm的j9虚拟机",
    "title": "第2章 Hello World",
    "section": "2.2 IBM的J9虚拟机",
    "text": "2.2 IBM的J9虚拟机\n\nIBM J9虚拟机名称的由来\nIBM官网上介绍，这款JVM最早是由IBM Ottawa实验室一个SmallTalk的虚拟机扩展来的。那时候，这个虚拟机有一个bug是因为8k值定义错误引起，工程师们花了很长时间终于发现并解决了这个错误，此后这个版本的虚拟机就被称为K8了。于是，后来出现的支持Java这个版本的虚拟机就被称为J9了。\n\n与Sun公司收购HotSpot类似，IBM的J9也是收购的。1996年，IBM收购了一家叫OTI（Object Technology International）的公司，该公司有虚拟机产品。更巧合的是，这个产品最初也是为SmallTalk语言设计的虚拟机，后来在Java流行以后，才改为支持Java虚拟机。\n2017年，J9变成了IBM主导的Eclipse组织的一个项目，名字已经改成了Eclipse OpenJ9。现在建立在Eclipse开放运行时项目（OMR）之上，IBM的专有项目大部分基于此，它完全兼容Java认证。"
  },
  {
    "objectID": "chapter2.html#bea的jrockit",
    "href": "chapter2.html#bea的jrockit",
    "title": "第2章 第一行代码",
    "section": "2.2 BEA的JRockit",
    "text": "2.2 BEA的JRockit\nBEA公司目前已经被Oracle收购，所以，Oracle拥有三个最主要的虚拟机中的两个。\nBEA公司是著名的Java中间件公司，曾经是IBM公司最重要的竞争对手，产品是与IBM WebSphere竞争的WebLogic，IBM有自己的Java虚拟机，BEA也想有自己的Java虚拟机。\n收购是最省时间的方式，BEA就收购了Appeal Virtual Machines公司，这个公司的产品是JRockit。\n从名字可以猜一下，应该和火箭一样快吧。JRockit的特点就是速度快，针对的市场是用专门硬件，专门服务器的商业用户，不针对消费者市场。这个公司宣传自己的产品是：“World’s Fastest JVM”，世界上最快的Java虚拟机。\nBEA被Oracle收购以后，就被Oracle暂停了，Oracle没必要同时拥有两个Java虚拟机。在2011年，Oracle宣布JRockit可以免费使用，但是由于多年没开发，JRockit最高只能支持Java 6。Oracle承诺，会将JRockit的优秀特征在OpenJDK实现。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#微软的jvm",
    "href": "chapter2.html#微软的jvm",
    "title": "第2章 第一行代码",
    "section": "2.3 微软的JVM",
    "text": "2.3 微软的JVM\n微软也出过Java虚拟机，并且性能还相当不错，在1997和1998年获得过《PC Magazine》杂志的编辑选择奖，在1999年宣称自己是Windows上最快的Java虚拟机。\n微软为什么会花大力气帮助Sun来实现Java虚拟机呢？答案当然是想控制Java了。因为Java，Sun在1997年控告微软违反协议滥用Java。直到2001年，微软败诉，赔偿2000万美元给Sun公司。\n后来微软山寨了Sun的Java，强推自己的Visual J++，官司输了以后，又开发了J#和C#，再推广JVM对微软已经没任何正面意义，所以，微软的JVM在2003年就停止开发，最晚支持到2007年。\n有个大翻转比较有趣，Sun在赢了官司以后，按照协议，Windows XP不能预装JVM。Sun此时才回过味来，如果不预装JVM，那么对于推广Java百害而无一利，于是又开始劝微软继续装JVM。\n那时Sun公司已经发布了Java 1.4，微软只肯在Windows XP Service Pack 1中包含一个1997年的，基于Java 1.1.4版本的JVM。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#apache的harmony",
    "href": "chapter2.html#apache的harmony",
    "title": "第2章 第一行代码",
    "section": "2.4 Apache的Harmony",
    "text": "2.4 Apache的Harmony\nApache也有JVM，但是却不能称之为JVM，前面讲过，想宣传自己为JVM，要先得到JCP主导的TCK兼容性测试。Apache得不到这个认证。\n为什么会得不到这个认证呢？主要还是理念问题。\nJCP的执行委员Doug Lea如此评价Oracle：“虽然Sun Microsystems已经制定了可以推动JCP创新的规则，但是Oracle并不理会这些规则，JCP也许会成为任Oracle摆布的傀儡。”\nApache组织是个非盈利组织，Oracle是个以盈利为主要目的公司。理念谈不拢。Apache希望Java能够不受任何公司的控制，让Java完全开源，做了名为Harmony的Java版本。\n后来，Java的创始人James Gosling也建议Oracle应该成立一个独立的JCP来控制Java，但是Oracle不为所动。2010年，JCP开会讨论Java 7和Java 8的方向，这次会议双方的矛盾最终爆发，Apache宣布退出JCP，Oracle乐见其成。\n本来IBM，Apache和Google是推动Harmony的三巨头，但是IBM却发表声明说今后将退出Harmony，以最大的努力推动Oracle的OpenJDK的发展。随后，IBM辞去了Harmony项目主席的职位。\nApache一方面无法得到TCK认证，另一方面，最坚定的支持者之一IBM也跑去了Oracle的阵营。在这种境地下，2011年12月16日，Apache宣布取消Harmony这个JVM的开发。\n该项目包含一个名为动态运行时层虚拟机（Dynamic Runtime Layer Virtual Machine，DRLVM）的Java虚拟机实现，从官方文档介绍上说，该实现对Java 6类库的完成度超过了97%，我在写书的时候，花了不少时间来研究这个97%是如何计算的，没找到更详细的信息。\nApache有一个坚定的支持者，就是Google。Google的安卓系统是Java的最大用户之一，他们始终不愿意让Oracle掌握命脉，于是，他们坚定的走Apache的Harmony道路，开发自己的JVM。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#google的dalvik",
    "href": "chapter2.html#google的dalvik",
    "title": "第2章 第一行代码",
    "section": "2.5 Google的Dalvik",
    "text": "2.5 Google的Dalvik\nAndroid是Google最大的资产之一，凭借Android，Google掌握了手机市场。Sun公司虽然一直想把Java推广到手机中，但是应该没有想到Google把这事做成了。\n\n\n\n\n\n\nDalvic名字的起源\n\n\n\nDalvik由Dan Bornstein编写的，名字来源于他的祖先曾经居住过的小渔村达尔维克（Dalvik），位于冰岛埃亚峡湾。\n\n\n在Apache宣布不再继续Harmony虚拟机以后，Google从中获取了大量的代码添加到Google Android SDK中。在2010年JCP投票中，Google和Apache坚定的站在一起反对Oracle，Google也就顺理成章的没有获得TCK认证。当然， Google的Dalvik虚拟机压根就没打算取得Oracle的认证，再加上后来的Android Runtime，Google从不承认自己的产品是JVM。\n情况确实有点复杂。除了Harmony虚拟机，Android还使用了一个交叉编译器来生成支持非Java虚拟机的不同的文件格式dex。\n从2015年开始，Google已经不再采用Apache Harmony的类库，转而采用OpenJDK。无论如何，我总觉得它是一种魔改版的JVM。\n介绍了前面几种JVM，这只是其中一部分比较出名的。据我所知，有非常多的Java虚拟机，因为相对于庞大的Java类库，虚拟机的实现成本要小的多。相比于数量众多的Java虚拟机，历史上只有三个独立的Java类库，它们分别是：OpenJDK、GNU Classpath和Apache Harmony。目前仍然活跃的类库只有硕果仅存的一个：OpenJDK。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#总结",
    "href": "chapter2.html#总结",
    "title": "第2章 Hello World",
    "section": "2.7 总结",
    "text": "2.7 总结"
  },
  {
    "objectID": "chapter2.html#我的感慨",
    "href": "chapter2.html#我的感慨",
    "title": "第2章 第一行代码",
    "section": "2.6 我的感慨",
    "text": "2.6 我的感慨\n现在的JDK更多，如果你去搜的话，出名的至少数十个，不知名的就更不计其数了，每家稍微大点的公司都有自己家的JDK。\n为什么会这样呢？因为每家公司都不能依赖别人，是的，不止每家公司，每个人都不能依赖别人。中国有句古话叫靠山山倒，靠人人跑。\n在不久以前，开源的C++的编译器只有gcc这一家，苹果公司当时还没有现在这么有统治力，在苹果公司的开发工具xcode中，使用的是gcc这个编译器。那……会有问题么？\n就像蛋蛋被别人捏住一样，虽然你的朋友可能不会捏，但是你总担心万一哪天，他一使劲，你不就完蛋了么？每当苹果公司需要gcc的某些功能的时候，gcc总是爱理不理，钱留下，功能，慢慢排期吧。于是，Apple也就不再纠结了，自己做自己的工具链。于是Apple开发了自己的LLVM，Clang，不用再仰人鼻息。\n大的公司不但要有自己的JVM，还要有自己的编程语言，比如Apple家的swift，Google家的Go，Microsoft家有自己的C#……\n当你认为别人可能会攻击你的时候，那他一定会攻击你。这是我看《动物世界》最大的感慨，动物从来不攻击年富力强的动物，专门挑老弱病残来攻击，要么就攻击带娃的动物。只要你有弱点，那么这个弱点一定会成为攻击对象。中国有名言：麻绳专挑细处断。\n而人，是动物的一种。\n你的年龄会成为劣势，你的子女会成为你的软肋，如果你上有老下有小，年龄还偏大，并且还有贷款，好吧，你就是最弱的那个人。老板会欺负你，这几乎是肯定的。因为你没有能力反抗，你的身后什么都没有，搁在国外，加入个工会什么的，企业还是比较怕的。\n希望你能理解，为什么这些公司，拼命的要把握住自己的命运。也希望你能把握住自己的命运。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#常见问题",
    "href": "chapter2.html#常见问题",
    "title": "第2章 第一行代码",
    "section": "3.1 常见问题",
    "text": "3.1 常见问题\n\n3.1.1 bytecode是什么？\n我在IBM Developer上曾经看过一篇文章，文章的名字叫Java bytecode: Understanding bytecode makes you a better programmer在这篇文章里，作者说：“对Java程序员来说，理解bytecode类似于让C/C++程序员理解汇编语言”。\n\n\n\n\n\n\nKathleen Booth与汇编语言\n\n\n\nKathleen Booth女士在1947年发明了汇编语言，并且设计了伦敦大学第一个汇编程序与自动解码。\n汇编语言是一种非常低级的语言，一般不能在不同的平台之间移植。可以把汇编语言看作是机器语言的助记符，在不同的设备上有不同的机器语言指令集。\n\n\n“bytecode”里的byte有真实的含义，代表byte，也就是8个bit。8 bits会产生256个组合。Java虚拟机最多支持256个操作符。目前，只用了大概80%。可以把bytecode理解为“Java虚拟机的机器码”。\njavac的工作就是把Java源代码转化成bytecode。 不管是在Linux上生成的bytecode，还是在Windows上生成的bytecode，都是一模一样的，这构成了java跨平台的基石。",
    "crumbs": [
      "Home",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#javac是编译器么",
    "href": "chapter2.html#javac是编译器么",
    "title": "第2章 第一行代码",
    "section": "4.2 javac是编译器么？",
    "text": "4.2 javac是编译器么？\n肯定不是gcc那样的编译器，javac不产生机器码。javac产生的是bytecode，如果大家了解Windows上的dll文件，或者Linux上的so文件，它们的作用非常相似。\n在Java虚拟机中，负责产生机器码的是JIT（Just-In-Time）运行时编译器。\n在本书中提到javac是编译器，我的意思是编译成字节码。也可以认为Java上实际上有两种编译器，一个是Java字节码编译器，一个是JIT编译器。\nJIT编译器的工作原理是这样的：软件在运行的过程中，大部分时间用来运行少量的代码。当软件在解释模式下执行的时候，编译子系统会时刻监控软件的运行，并观察代码中执行最频繁的部分。在整个分析过程中，会捕获一些重要的信息，再根据这些信息进行优化，优化的原则是：把运行最频繁的部分，编译成机器码。这样一来，Java代码就拥有了可以和C/C++相媲美的性能。\n多说一句，如果你多年未关注编程语言的飞速发展，可能错过了一些精彩的时刻。目前，主流的编程语言都已经支持JIT技术，像PHP 8，JavaScript，Python都已经开始引入JIT技术，这也是开源技术的魅力所在，只要一项技术被证实可靠，就会被其它语言采用。\n对普通开发者来说，采用HotSpot的方法就很好。因为HotSpot采用的方法太复杂，普通开发者根本看不懂，看不懂就不会胡乱修改，反而不容易产生性能问题，只要跟着Java虚拟机升级就能获得益处。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter2.html#java虚拟机只能运行java语言么",
    "href": "chapter2.html#java虚拟机只能运行java语言么",
    "title": "第2章 第一行代码",
    "section": "4.3 Java虚拟机只能运行Java语言么？",
    "text": "4.3 Java虚拟机只能运行Java语言么？\n以前是，现在不是。\nJava虚拟机和Java语言现在已经渐行渐远，虽然Java编译的字节码只能跑在Java虚拟机上，但是Java虚拟机并不是只跑Java的字节码。目前来说，Java语言和Java虚拟机在一定程度上是独立的，Java虚拟机也许应该换个名字，比如叫“万物虚拟机”更贴切一些。\n现在Java虚拟机可以执行任何语言生成的合法的文件，只要符合Java虚拟机的规范就好。比如目前比较热门的scala语言用其编译器scalac生成的字节码，完全可以运行在Java虚拟机上。\nJava虚拟机如果要加载类，会先验证它们是不是符合规定的格式，如果符合，就允许其执行。本书不会对类文件的规范讲的太深入，只讲一个有点意思的事情吧。\n在Windows上，可以用扩展名来识别文件类型，在Unix环境下，则要使用一些魔数（magic number）来识别。每个Java类文件都以魔数0xCAFEBABE开头的，这四个以十六进制表示的字符表示当前文件的类型。大家看到没有，最后四个字母是BABE，当年Java可能没想到会这么火，也没想到这个单词放在今天的舆论下，会涉及性别歧视。现在有转机了，在Java 9中，为模块文件（JIMAGE）引入了新的魔数0xCAFEDADA。也不知道“爸爸（DADA）”这个单词会不会在未来的日子里，也有歧视的意味。\n比起社会的文化的变革速度，Java的更新速度其实很慢的，所以我们要长期使用到0xCAFEBABE这个魔数，不过，如果你不用十六进制编辑器打开二进制文件，是不会看到这个涉嫌性别歧视的字串的。顺便提一句，github这个网站，因为master这个词语涉嫌种族歧视，从2020年10月开始，新建的仓库的默认分支名由master改成main。\n\n\n\n\n\n\nWarning\n\n\n\n世界发展的非常螺旋🌀，一方面，BABE涉嫌对女性的歧视，Master涉嫌对当年黑人的歧视，纷纷做出了修改。另一方面，歧视好像没有减少，越不让说，通过罚款，把人嘴堵住的方式，会不会让歧视从显性到隐性呢？\n比如，当年有一个叫Sarah Sharp的女性开发者对Linus抱怨，指责Linux内核开发者邮件列表让她感到不舒服。原因是，内核开发者都是一些“生活在黑乎乎地下室里的，只有地震、伽马射线与妈妈”才能伤害他们的人。Linus的邮件中，经常出现一些“不礼貌”的用词。后来失控了，Linus也被迫向女性朋友们道歉。\n这件事过去十多年了，根据我的观察，即使Linus不太敢大嘴巴喷人了，女性内核开发者也没增加。（至少出名的内核开发者，还是那几个“老人”）。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter3.html",
    "href": "chapter3.html",
    "title": "第3章 面向对象编程",
    "section": "",
    "text": "难难难，\n编程难，\n面向对象谈一谈，\n对了对象谈几句，\n不对对象枉费口舌尖！\n找对象难，找个对的对象更难，跟对象过日子是男上加男。但是凭良心说，在编程中，面向对象是真不算太难。\n本章，且听我从头考证，细细说来。考证中，我发现面向对象的发展过程中，至少6个科学家因此获得图灵奖。更神奇的是，这些科学家对面向对象的看法并不统一。但是，都不同程度的受到了第一门面向对象Simula的影响。幸好，有很多的论文可以读，我发现，几乎所有的面向对象的概念，都已经在Simula中包含了，只是后来的语言，侧重点不同。Java也只是其中之一。Simula语言的故事，我觉得还挺有趣的，也是本章的重点。\n但是写书，就要多写点，详细点。本章的计划是通过研究面向对象的历史来学习面向对象编程，具体的技术细节在第9章再讲，如果没有其它面向对象编程语言的经验，这一章中碰到不懂的问题直接跳过即可。\n对C++或者Python语言来说，可以使用面向对象编程，也可以不使用面向对象编程。但是对Java来说，没有面向对象就没法编程。从这个意义上来说，Java是一种非常纯粹的面向对象编程。那面向对象有什么作用呢？James Gosling在接受采访时说：“面向对象可以使你把一个系统分解开，系统的每个部分都能够被分解，这样对更新、调试等很多事情都有帮助。”\n既然面向对象此的重要，我们不妨来研究一下面向对象的历史。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#footnotes",
    "href": "chapter3.html#footnotes",
    "title": "第3章 面向对象编程",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n如果大家对FIFA的操作有兴趣，可以到xueban.app这个网站中查看具体的动作，我当年闲的蛋疼，练了不少花哨动作。实际上，一般玩家常用的动作在10种以下。而且吧，如果你跟哥们踢球，玩的太花，容易被打。↩︎\n在2010年的时候，EA通过不停的收购，拥有了很多世界知名的游戏品牌，但是也带来了一个巨大的麻烦，当时EA有十三款不同的游戏引擎，有虚幻引擎开发的《质量效应2》，有变色龙引擎开发的《极品飞车》，这导致暴涨的开发费用。↩︎",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#面向对象发明人",
    "href": "chapter3.html#面向对象发明人",
    "title": "第3章 面向对象编程",
    "section": "1.1 面向对象发明人",
    "text": "1.1 面向对象发明人\n1952年，二战结束不久，挪威政府决定成立一个叫NCC（Norwegian Computing Centre）的组织，把全国零散的计算机资源整合起来。说起来容易，做起来难，因为这些计算机资源都分散在全国各个部门，比如有的在NDRE（Norwegian Defence Research Establishment）这样的军方部门，有的在奥斯陆这样的大学，还有的在工业界。之前的挪威，还没有一个组织可以协调所有的部门，NCC为此而成立。\n在二战的时候，所有国家都知道了计算机的威力，挪威也不例外。毕竟挪威是在二战中与纳粹德国抗争时间坚持第二长的欧洲国家，仅次于俄国。战后，1954年，他们研发了第一台计算机，名字叫NUSSE（Numerical Universal Automatic Sequential Electronic Computer），这是一台真空管计算机。该真空管计算机制作完成以后，就被运到了上面所说的新成立的NCC里。\nNCC刚成立的几年，除了这台NUSSE真空管计算机，没有其它的计算机。拥有最多计算机资源的是挪威军方NDRE，在当时战争的影响尚未完全消退的大环境下，任何国家都是如此，军方优先拥有最多的计算机资源。军方要制造自己的核反应堆，根本没有多余的计算机给别人。NCC和NDRE这两个组织同时存在，计算机资源都很贫瘠，地主家也没有余粮，多一个组织，多一个僧，这两个组织反而加剧了僧多粥少的竞争关系。\n军方要增加自己的计算机资源，就从英国的Ferranti公司买一台名为 Mercury的电脑。该项目的负责人叫Jan Garwick，之前在奥斯陆大学当教授，他招了两个人来当助手。\n其中一个助手是1952年加入的新兵，他就是Ole-Johan Dahl，他的任务是给Mercury那台电脑写一个编译器，这个编译器叫MAC（Mercury Automatic Coding）。\n另一个助手也是个士兵，是1948年入伍的Kristen Nygaard，他被安排了另外一个项目，该项目是研究一个开放性的问题：如果有一天挪威要制造核武器了，应该如何提前模拟核武器的爆炸威力？\nKristen Nygaard以模拟核武器为题写了一篇名为《Theoretical Aspects of Monte Carlo Methods》的论文，随后在军方成了专职的核武器研究员。虽然他的专职工作是研究核武器，但是他兴趣广泛，他的研究范围从单纯的核武器扩大到世间万物，尤其是人力资源能不能也用计算机来建模呢？他对此很有兴趣。\n他希望他的方法可以管理社会的组成单位：人。他想通过计算机模拟，使用统计学的方法来解决人工作效率不高的问题。通过计算机来模拟现实世界，这样想法听起来非常的诱人，尤其引起了苏联的注意，当时苏联是计划体制，如果人也可以被计算被管理，那就再好不过了。\n这是一种将社会工程学和管理学相结合的产物，Kristen Nygaard研究人的行为并加以预测和控制。苏联对此十分热衷，一直跟进他的研究，一旦有成果，苏联就把成果在自己的乌拉尔大型机上实现出来。\n后来Kristen Nygaard与军方发生了一些摩擦，他于1960年离开军方并加入前文提到的NCC。相比于军方，NCC更多倾向于民用研究，在这里，他有更大的空间可以自由的发挥。在此，他思考这样一个问题，能不能将他在军用上做的工作转成民用呢？\n一封当时保留下来的信如实记录了当时的情况，1962年，Kristen Nygaard给法国计算机科学家Charles Salzmann写了一封信，在信中他透露说他已经有了完整的模拟现实世界的概念，还没动手写语言的编译器，他想等语言先设计好了再动手做这个工作。他认识一位写程序的天才，两人都表示很乐观。在这封信里他提到的那位天才就是他未来的合作伙伴Ole-Johan Dahl。\n\n\n\n\n\n\nTip\n\n\n\n这封信可以在这个网址查看：http://cs-exhibitions.uni-klu.ac.at/index.php?id=37\n\n\n这两个年轻人在1962年终于开始共同工作了。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#simula的研究成果",
    "href": "chapter3.html#simula的研究成果",
    "title": "第3章 面向对象编程",
    "section": "1.2 Simula的研究成果",
    "text": "1.2 Simula的研究成果\n1963年，他们两人开始研究并实现这个创意，两年后，于1965年完成第一阶段工作。这个阶段的成果在当时被称为Simula，为了区分，后被约定俗成称之为Simula I。\n随后的两年，两人继续研究，于1967年发表了第二版本的语言，也就是后来的Simula 67，Simula 67已经有了面向对象的雏形，几个与面向对象相关的概念已经被提出。我们看看这几个重要的概念吧。\n\n1.2.1 错误检查\n由于Simula语言最初研究的是核爆炸，安全性显得特别重要，与其它同期的语言不同，Simula格外重视安全，毕竟核爆炸可不是只让电脑死机那么简单了。Simula在设计之初对错误十分重视，Simula设计了两种错误检查，一种是编译时检查，一种是运行时检查。\n现在我们把这种机制叫做类型安全（type safety）。\n程序员在讲到类型安全的时候，不同语言的程序员，对这个概念的理解十分不同，讲出来的意义也就十分的宽泛。\n在本书中，我所指的类型安全不仅是对一个A类型的变量赋值了一个B类型的值，[^ 2] 更多的是考虑到类的层面，比如每个对象创建后都要初始化，外部对类的访问要受相关的限制，对象抛出异常之前要先将自身重置到合法状态等等。类型安全的思想贯穿于整个编程中，而不仅仅在变量赋值这种技术细节。\n不止Java借鉴了Simula的错误检查，目前像Haskell语言中的inspect方法或多或少都是从这里学来的。\n\n\n1.2.2 继承\nOle-Johan Dahl曾经这样写过：“增量的抽象，对已经抽象过可以加上一个前缀C，只要有这个前缀C，就可以使用其所有的属性。这就是继承的雏形，虽然还没有正式叫继承。”\n其实对任何语言来说，都可以复用代码，至少可以通过简单的“复制粘贴”来完成代码的重复使用，但是这样复用的代码并不优美，而且还很难维护。如果能够直接使用别人已经完成的代码，或者自己先前抽象好的代码，而不是自己再重新开始，那么将会有效的降低工作量。Simula语言在这个方面进行了探索。\nJava当然也借鉴了这个思路，Java围绕类的概念做了很多工作，其中最重要的概念之一就是：“继承”。在以后的章节里，我会详细介绍继承的概念。\n望文生义，继承的表面意思就是从“长辈”那里得来一些东西，在Java中，基本也是这样的，采用已有的类，无需改动这些类，就能获得相应的功能，这种方式在Java中也叫“继承”。\n\n\n1.2.3 内存回收机制\nOle-Johan Dahl和C.A.R. Hoare合作写过一篇论文《Hierarchical Program Structures》 ，在这篇论文中，他们介绍了当时的想法：“在实现Simula的时候，借鉴了Algol 60这个编程语言的实现方法，并且对Algol 60的block进行了必要的改进，将block视为数据，其它的程序可以使用这些block，这后来演化成了类的使用方法。”\nSimula语言的两位作者写的《The Development of the Simula Language》里， 也提到了这一点：“改进了存储机制，引入了内存垃圾回收机制。也许很多语言都意识到了Algol block的威力，但是第一个意识到并且做出垃圾回收的语言是Simula，这在当时是一件了不起的创举。虽然内存垃圾回收很难，还有可能对语言的运行速度产生影响，但是为了以后程序员的方便，这点性能缺失不算什么。Simula还独创了一种名为二维空闲列表的方式来负责内存垃圾回收。”\n在计算机科学中，内存泄漏（Memory leak）是一种常见的bug，由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。\n内存泄漏会因为减少可用内存的数量从而降低计算机的性能。最终，在最糟糕的情况下，过多的可用内存被泄露掉从而导致全部或部分设备停止正常工作，最终导致应用程序崩溃。\n现在主流的编程语言如Java就提供了内存回收机制，这对保证软件的可靠性和安全性非常有好处。如果大家有C/C++编程经验的话，很可能为了一个内存泄露花费数小时甚至数周来查找。有了内存回收机制以后，将节省大量的编程与调试时间。\n\n\n1.2.4 动态绑定\nSimula开创性的使用了动态绑定技术，虽然当时的名字不叫dynamic binding，而是叫virtual。刚开始的时候，Simula所有的属性都是静态的。Ole-Johan Dahl是在最后一分钟才决定做成动态的，如果对属性定义为virtual，那么就可以动态绑定了。后来的语言如Smalltalk更纯粹，直接把所有的属性和方法都定义为virtual，在C++中也用相同的关键字virtual。\n\n\n\n\n\n\nNote\n\n\n\n以上讲的这部分内容也在《The Development of the Simula Language》这篇文章中。大家可以自行搜索，或者到xueban.app上下载，如果能少刷两小时抖音看美女，看看这篇文章我觉得是值得的！\n\n\nJava语言同样借鉴了Simula语言，在默认情况下是可以动态绑定的，如果使用了final这个关键字，就是静态绑定从而阻止被覆盖。\n\n\n1.2.5 小结\n如果用Peter Wegner在1987年对对面向对象下的定义：object-oriented = objects + classes + inheritance来衡量的话，至此，面向对象最重要的几个要素在Simula语言中都已经有了雏形。\n\n\n\n\n\n\nPeter Wegner介绍\n\n\n\nPeter Wegner是一位出生于1932年的英国科学家，对面向对象编程有很大的贡献。\n在1999年，他被奥地利授予奥地利科学与艺术荣誉奖，在去伦敦领奖的路上，出了车祸，昏迷了好久之后才苏醒，但是有了严重的后遗症。\n\n\n如果只有技术，没有推广，Simula可能仍然会像世界上绝大部分的编程语言一样无闻。著名的科技史作家、宾夕法尼亚大学历史学教授Thomas Parker Hughes在爱迪生的传记《Networks of Power: Electrification in Western Society》里这样评价：“像爱迪生这样伟大的发明家有这样的特征，为了达成目标，他们不仅有超越普通人和科学家的认知，还能够综合利用自己的社会关系，政治资源，商业手段。”\n我觉得强有力的推广这种优秀的品质，在Simula两位创始人身上体现的也很明显，两位创始人不只是可以埋头搞科研的人，同样和爱迪生一样是政治和商业上的天才。他们不仅有雄心壮志，同样也有政治动员能力、商业运作水平，这两位创始人靠着自己无与伦比的谈判技巧和推广能力，把Simula语言从挪威推广到了整个英国、法国、美国、苏联，最后影响了全世界。\n虽然这是一本编程的书，我还是希望大家能学到比编程更多的东西。要记住，酒香也怕巷子深。能够把一门编程语言推广起来，可不是一件容易的事情。\n当你写出一款优秀的软件，或者创造了一个编程语言，只是成功走完了第一步。如何推广软件或者语言，让别人用你的软件或者语言，是更重要也是更困难的一步。接下来学习一下Kristen Nygaard和Ole-Johan Dahl是如何推广Simula的吧。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#推广simula",
    "href": "chapter3.html#推广simula",
    "title": "第3章 面向对象编程",
    "section": "1.3 推广Simula",
    "text": "1.3 推广Simula\n挪威不是计算机强国，如果要推广自己的Simula语言，就要先在计算机上运行。在当时，计算机是非常昂贵的，NCC有意从英国购买KDF-9这台大型计算机，但是这台计算机的价格实在太贵了，远远超出了NCC的预算。当时美国已经制造出了UNIVAC这样一台机器，NCC想购买这台电脑。\n\n\n\n\n\n\nTip\n\n\n\n再宣传一下我做的名字叫《软件那些事儿》的podcast，在这个电台的200期到203期里，我讲过UNIVAC这台计算机。可以通过泛podcast客户端搜索收听。\n\n\nKristen Nygaard表现出了天才般的谈判技巧，他找到了UNIVAC在欧洲的负责人James W. Nickitas，经过了一次谈判，他说服了对方，对方同意把UNIVAC打5折。还敲定了下一次会谈，要和UNIVAC软件的灵魂人物Robert Bemer——前IBM计算机的核心之一——坐下来谈谈软件和编程语言的事情。\nUNIVAC的软件核心Robert Bemer在和Kristen Nygaard谈过以后，UNIVAC不仅可以以半价卖给NCC，而且还给Simula项目带来了一笔赞助，还有，Kristen Nygaard成了北欧UNIVAC的销售代理。这样的谈判水平，已经可以说是高手中的高手了。\n这种谈判并不是只发生了一次，在Kristen Nygaard推广Simula的时候，这种事情屡次上演，他总是能把最难谈的谈判像谈天一样搞定，很快Simula就可以在UNIVAC，IBM360/370， CDC 6000， DEC System-10等一系列当时最主流的机器上运行了。\nKristen Nygaard不仅对编程和计算机有兴趣，他一生还投入了大量精力去做政治运动，始终站在劳动者一边，争取劳动者的权力。\nSimula影响了工业界和学术界，也培养出了一大批Simula的拥趸，比如Smalltalk的作者Alan Kay，C++的作者Bjarne Stroustrup都曾声称自己的语言深受Simula的影响。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#什么是对象",
    "href": "chapter3.html#什么是对象",
    "title": "第3章 面向对象编程",
    "section": "2.1 什么是对象",
    "text": "2.1 什么是对象\n1995年，James Gosling写了第一份Java白皮书《The Java Language Environment》，在这本白皮书的第三章，详细的介绍了什么是对象(object)。\n当时是1995年，人们对“面向对象”有很多争论，现在20多年过去了，争论的声音越来越少。就像现在谈起“面向过程”编程，几乎没有什么争论一样，“面向对象”也要经历同样的过程，尘埃会慢慢落定。\n生活中充满了对象：车、咖啡机、鸭子、树都是对象。软件也由对象组成：按钮、菜单、图标也都是对象。无论是生活中，还是软件中的对象，都有自己的状态和行为。如何把现实中的“对象”建立在计算机中，是“面向对象”要解决的问题。\n我们可以对一辆现实中的汽车进行建模，让其对应于计算机中。一辆汽车有其状态（车速、油耗、颜色、手动档还是自动档等等）和行为（启动、转向、停车等）。\n\n\n\n现实中的对象与编程中的对象\n\n\n当我们开着这辆车去上班后，可能会在办公室里查查自己买的股票，看看是不是又融断了。股票也是对象，也可以映射在电脑里，也有自己的状态（最高价、最低价、开盘价、收盘价等）和行为（股价波动、退市等等）。\n看完十天融断四次的股票，你头晕眼花，想去冲一杯咖啡缓一缓。咖啡机也有自己的状态（水温、咖啡种类等等）和行为（加热、搅拌、流出一杯Java咖啡等等）。\n所有这一切都可以映射为对象。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#名词搅拌器",
    "href": "chapter3.html#名词搅拌器",
    "title": "第3章 面向对象编程",
    "section": "3.1 名词搅拌器",
    "text": "3.1 名词搅拌器\n用2000多年前孔子的话来讲：“道不远人”。道并不远离人的日常生活，一个人修道的时候如果远离人的日常生活，那他修的就不是道了，用武侠小说中的话来说，可能已经走火入魔了。面向对象编程也是如此，不管这个技术多好，都不能远离程序员太多，如果这种技术已经让大部分程序员搞不懂了，那就不是好的编程技术。\n如果面向对象编程让程序员有亲近感，首先在语言上要平易近人。显然，面向对象编程在这一点上做的不好，甚至可以说很差。面向对象有大量的名词，这些名词像把一本新华字典丢进了一个搅拌器，随机搅拌了一堆词语出来，比如下面的词汇：\n泛化、特化、父类、多态、属性、委托、注入、构造函数、异常、框架、类库、组件、模式、用例、建模、重构、敏捷、重写、集合、关联……\n这只是举了一部分中文的，还有大量英文缩写的没有列出来。这种名词搅拌器一样的编程语言，确实让人很头疼。如果是初学者，一看到这些名词，就已经吓的不敢深入学习了。\n存在大量的术语有多方面的原因，如果了解了背后的原因，就不会如此纠结了。\n一部分原因是广告的需要，公司推广一项技术，就要写的云山雾罩的，这样显得比较有技术含量。这个不仅是技术行业，在任何行业都是这样，以化妆品为例，我经常盯着老婆化妆品上那些诸如“活泉精华”“抗氧精粹油”发呆，每个字都认识，连起来就是不懂这是什么黑科技。\n还有一部分原因是技术人员故意避开以前存在的名字，以便显示自己的独创性，其实没没什么独创性，人类总是重复发明旧的科技，然后新瓶装旧酒，用新的名字包装旧的技术。比如Java中的多态（polymorphism），这个技术无论是内涵与外延，都和动态绑定（dynamic binding）是一样的，后来又来了一个后期绑定（late binding）和一个运行时绑定（run-time binding）。同一个类似的技术，一下子有了四个名字。这种情况在面向对象的技术发展过程中实在是太普遍了，大家一定要一眼看穿这种鬼把戏。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#过度宣传",
    "href": "chapter3.html#过度宣传",
    "title": "第3章 面向对象编程",
    "section": "3.3 过度宣传",
    "text": "3.3 过度宣传\n其实，比起现在的宣传，如果说编程的宣传有点捕风捉影，现在的宣传简直就是平地扣饼，编程已经是已经很内敛了。\n\n面向对象编程是正确程序的替代品。 （object oriented programs are offered as alternatives to correct ones.）—— Edsger W. Dijkstra\n\nDijkstra的这句话提醒我们不要教条，过度宣传会给用户不切实际的幻想，经过30多年坚持不懈的宣传，让程序员误以为就没有面向对象解决不了的问题，我把这称之为“面向对象”综合症。\n通过前面介绍Simula 67的历史，我们会知道Simula 67这个面向对象语言的先驱，当时并没有“发明”出面向对象这个概念，而是后来Smalltalk语言的作者提出的。在Simula 67中，引入class的作用仅仅是汇总子程序和变量的结构，到了Smalltalk中才开始使用继承结构来组织类库，所有的类都来自于Object类。\n由于Smalltalk和C++的流行，面向对象的概念已经不是某个人能左右的了。这种现象已经不能用技术来解释了，让我想起了郭德刚讲的一段相声，当一个人听到一个段子的时候，会添油加醋的渲染一番，然后再传给下一个人，下一个人也是如此这般，等传到十个人的时候，事情已经面目全非了。\n以我工作的经历，那些完全不懂技术的领导也知道面向对象的好处，而且很有主见。领导或者项目经理在给程序员提意见的时候，经常说：“不要想得那么难，用面向对象的方法，对这些东西建个模，很容易的。”然后，我还要装作恍然大悟的样子夸领导几句。\n这都是过度宣传导致的结果，面向对象编程被包装成了无所不能的银弹。虽然现实世界是由一个又一个的对象组成的，但是想把现实世界映射在程序中，并不容易。\n\n\n\n\n\n\nNote\n\n\n\nIBM大型机之父佛瑞德·布鲁克斯写过一篇论文《没有银弹：软件工程的本质性与附属性工作》。\n在这篇论文中他强调强调由于软件的复杂性本质，而使真正的银弹并不存在；所谓的没有银弹是指没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍。\n其中银弹（Silver Bullet）的来历是：在欧洲民间传说及19世纪以来哥特小说风潮的影响下，银弹往往被描绘成具有驱魔功效的武器，是针对狼人等超自然怪物的特效武器。后来也被比喻为具有极端有效性的解决方法，作为杀手锏、最强杀招、王牌等的代称。\n\n\n两界普利策得主约翰·卡雷鲁写过一本书叫《坏血：一个硅谷巨头的秘密与谎言》，在书里他这样写道：“雾件（Vaporware）反映了计算机行业的一种倾向，在涉及市场营销时，做法非常轻率散漫。微软、苹果和甲骨文都曾被谴责某些时候都有类似的做法，过度承诺是硅谷的标志性特征之一。”雾件（Vaporware）这个词现在已经不太出现在媒体上了，但是这种过度吹嘘的行为至今仍然存在，甚至愈演愈烈。\n以上就是面向对象为什么这么难的原因。\n很多的程序员并不清楚为什么要用面向对象编程，也不了解面向对象编程的历史，反正大家都在用，有关面向对象编程的工具有很多，有好用的IDE，有UML工具，那我也跟着用用就好了。在这种心态下，面向对象编程就成了一种很神秘的东西，“虽然不理解，但是大家都在用”。\n本书要做的事情就是尽量把Java和面向对象的知识点讲清楚。为尽量避免上面讲到的三种缺点，本书会使用如下的原则：\n1． 为了避免名词搅拌器，尽量不过多引入术语。\n2． 会使用隐喻，但是不会到处使用隐喻，最终还是会落实到代码上。\n3． 不过度的宣传Java以及面向对象的强大，而是从为什么引入这种技术以及这些技术能解决什么问题的角度来讲解。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#滥用隐喻",
    "href": "chapter3.html#滥用隐喻",
    "title": "第3章 面向对象编程",
    "section": "3.2 滥用隐喻",
    "text": "3.2 滥用隐喻\n在著名的《代码大全》这本书里，第二章讲了隐喻对理解软件开发的影响。如果选择错了隐喻，那么就会对软件开发有很大的误解。\n同样，在面向对象中，如果乱用隐喻，也会让人对面向对象产生误解。\n前文3.2小节举的例子是参考James Gosling写的Java白皮书《The Java Language Environment》的第三章。把现实中的对象映射为编程中的类，有助于理解面向对象编程，但是同时也有副作用，会让读者误以为现实事件的物体都可以映射为类。实际情况并不是这样的。\n现实中的物体不是由类创建的，而且和面向对象编程中的类大相径庭。现实中的人是父母生的，不是类创建出来的实例。除此之外，现实中的人会根据场景的不同有多种角色，比如我在公司是“员工”，在家里是“父亲”和“丈夫”，对父母则是“儿子”。\n但是在Java面向对象编程中，一旦根据类创建了实例，那么这个实例就只属于唯一的类，无论时间空间怎么改变，都无法改变这个实例的类型与行为。现实中的我，随着时间的变化，已经从“后浪”成了“前浪”，从“少年”变成了“大叔”。\n软件只能涵盖人类工作的一小部分，并不因为引入了面向对象编程而让软件有质的变化。虽然在在推广和宣传面向对象编程的过程中，有意无意的夸大了该方法的优点，但是我们程序员切不可认为面向对象真能模拟现实世界。\n在面向对象编程以后，还曾经兴起过一个叫“面向代理”的技术浪潮，但是这个技术很快销声匿迹了。“面向代理”的技术在宣传的过程中，有点类似“人工智能”，能够主动的创造软件，自主的响应人类的需求。很可惜，目前的技术实现不了所宣传的目标。\n有了计算机，大量的工作仍然要用人来实现。目前的计算机架构决定了无法完全顶替人类来完成现实世界的工作。引用《Code: The Hidden Language of Computer Hardware and Software》的作者Charles Petzold的话来说：“人类有很多的交流形式不能用非此即彼的可能的选择来表示，但是这些交流形式对我们人类的生存又非常重要。这就是人类为何没有与计算机建立起浪漫关系的原因（无论如何，我们都不希望这种情况会发生）。如果你无法用图画或者声音来表达某种事物的时候，你就无法将这个信息用比特的形式来编码。”\n是啊，像林俊杰的歌中唱的：“确认过眼神，我遇上对的人。”如果你相信面向对象可以对世间万物进行建模，那么，我们如何能用面向对象的方法对眼神进行建模呢？\n隐喻能帮助我们理解面向对象编程，但是也会让干扰我们对面向对象编程的理解。这也是面向对象编程难以理解的又一个因素：滥用隐喻。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#对象怎么工作",
    "href": "chapter3.html#对象怎么工作",
    "title": "第3章 面向对象编程",
    "section": "2.2 对象怎么工作",
    "text": "2.2 对象怎么工作\n简单来说，人是对象的一种，人怎么工作，对象就是怎么工作。以牛马为例：牛马.拉磨()，牛马.吃(苦)，牛马.吃(饭)，牛马.喝(水)。\n这个“.”号就是Java中让对象工作的方法。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#过度宣传其实比起现在的宣传编程已经很内敛了",
    "href": "chapter3.html#过度宣传其实比起现在的宣传编程已经很内敛了",
    "title": "第3章 面向对象编程",
    "section": "3.3 过度宣传（其实，比起现在的宣传，编程已经很内敛了）",
    "text": "3.3 过度宣传（其实，比起现在的宣传，编程已经很内敛了）\n\n面向对象编程是正确程序的替代品。 （object oriented programs are offered as alternatives to correct ones.）—— Edsger W. Dijkstra\n\nDijkstra的这句话提醒我们不要教条，过度宣传会给用户不切实际的幻想，经过30多年坚持不懈的宣传，让程序员误以为就没有面向对象解决不了的问题，我把这称之为“面向对象”综合症。\n通过前面介绍Simula 67的历史，我们会知道Simula 67这个面向对象语言的先驱，当时并没有“发明”出面向对象这个概念，而是后来Smalltalk语言的作者提出的。在Simula 67中，引入class的作用仅仅是汇总子程序和变量的结构，到了Smalltalk中才开始使用继承结构来组织类库，所有的类都来自于Object类。\n由于Smalltalk和C++的流行，面向对象的概念已经不是某个人能左右的了。这种现象已经不能用技术来解释了，让我想起了郭德刚讲的一段相声，当一个人听到一个段子的时候，会添油加醋的渲染一番，然后再传给下一个人，下一个人也是如此这般，等传到十个人的时候，事情已经面目全非了。\n以我工作的经历，那些完全不懂技术的领导也知道面向对象的好处，而且很有主见。领导或者项目经理在给程序员提意见的时候，经常说：“不要想得那么难，用面向对象的方法，对这些东西建个模，很容易的。”然后，我还要装作恍然大悟的样子夸领导几句。\n这都是过度宣传导致的结果，面向对象编程被包装成了无所不能的银弹。4虽然现实世界是由一个又一个的对象组成的，但是想把现实世界映射在程序中，并不容易。\n两界普利策得主约翰·卡雷鲁写过一本书叫《坏血：一个硅谷巨头的秘密与谎言》，在书里他这样写道：“雾件（Vaporware）反映了计算机行业的一种倾向，在涉及市场营销时，做法非常轻率散漫。微软、苹果和甲骨文都曾被谴责某些时候都有类似的做法，过度承诺是硅谷的标志性特征之一。”雾件（Vaporware）这个词现在已经不太出现在媒体上了，但是这种过度吹嘘的行为至今仍然存在，甚至愈演愈烈。\n以上就是面向对象为什么这么难的原因。\n很多的程序员并不清楚为什么要用面向对象编程，也不了解面向对象编程的历史，反正大家都在用，有关面向对象编程的工具有很多，有好用的IDE，有UML工具，那我也跟着用用就好了。在这种心态下，面向对象编程就成了一种很神秘的东西，“虽然不理解，但是大家都在用”。\n本书要做的事情就是尽量把Java和面向对象的知识点讲清楚。为尽量避免上面讲到的三种缺点，本书会使用如下的原则：\n1． 为了避免名词搅拌器，尽量不过多引入术语。\n2． 会使用隐喻，但是不会到处使用隐喻，最终还是会落实到代码上。\n3． 不过度的宣传Java以及面向对象的强大，而是从为什么引入这种技术以及这些技术能解决什么问题的角度来讲解。",
    "crumbs": [
      "Home",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#fifa足球游戏",
    "href": "chapter3.html#fifa足球游戏",
    "title": "第3章 面向对象编程",
    "section": "4.1 FIFA足球游戏",
    "text": "4.1 FIFA足球游戏\n足球是世界第一大运动，上一届世界杯说有22亿人观看，这有可能是真的么？在游戏行业，有两个最著名的足球游戏，一个是KONAMI的《实况足球》，一个是EA出的《FIFA》。以FIFA 19来举例吧，假设EA把我们请去设计FIFA游戏，我们应该怎么做？\n想象一下，如果我们要去设计FIFA这款足球游戏。这个游戏里，有数百支球队，数百位教练，数千名球员，看台边上举着相机的记者，看台上数万球迷……想想头就大了。幸好，我们可以用面向对象的方法把所涉及的对象抽象出来。\n也许有些人没有玩过FIFA足球，为了讲编程概念比较容易，我先用文字描述一下吧，如果可能，自己找个视频看看，或者自己玩一下就更有直观的体验了。\n大家在电视里看过足球吧，FIFA游戏尽量模拟真实的足球，只是把控制权交给了玩家。玩家可以用手柄或者键盘控制场上踢球的球员。现实足球场上发生的一切，都尽量的在游戏中加以模拟。当然有所取舍，因为完全模拟是没办法做到的，如果仔细看得话，会看到场边有举着相机的记者，他们的动作是一模一样的，看台上的球迷也都雷同，场边的第四官员和教练动作也比较僵硬。原因就计算力有限，FIFA使用的寒霜引擎非常耗费资源。好钢用在刀刃上，好运算力用在渲染球员上。\n对这个游戏来说，最重要的部分是球员。让我们来看看如何抽象游戏中最重要的球员吧。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#对球员进行抽象",
    "href": "chapter3.html#对球员进行抽象",
    "title": "第3章 面向对象编程",
    "section": "4.2 对球员进行抽象",
    "text": "4.2 对球员进行抽象\n下面是FIFA 19中的截图，在FIFA中，球员有很多的属性，我挑一小部分说一下。\n\n每个球员都有名字，图里面用的是Messi，还有球员在场上的位置，Messi在FIFA 19是右边锋(RW)。再就是94这个能力值，这个能力值是FIFA游戏开发组给每个球员的综合评价，梅西和C罗是最高的94分。目前来说我知道是最低的能力值是天津权健的吴磊，能力值仅有48分，现在中超的射手王武磊能力值是76分。\n还有一些属性是国家：阿根廷（显示的国旗），所属的球队（巴塞罗纳）。还有下面数字分别代表的单项能力值（满分是100）：\nPAC(速度)：87\nSHO(射门)：92\nPAS（过人）：92\nDRI（盘带）：96\nDEF（防守）：39\nPHY（体能）：66\n以上列出了球员的状态，除了属性，还要列出球员的行为。\n\n\n\n\n\n\n当设计类的时候，主要考虑类的两个方面：\n\n\n\n\n这个类有什么属性？\n这个类有什么行为？\n\n\n\n球员在球场的行为有很多种，像FIFA游戏，场上的每个球员可以响应86种动作1，目前只需要列出其中的几种：停球，传球，射门，防守。根据这些属性和行为，可以画出如下球员类所示：\n\n\n\n球员的类图\n\n\n经过这样的抽象，我们把球员的信息得以大幅简化。编程首要的任务是控制复杂性，用这种抽象的方法能有效的简化编程过程，这样，我们可以忽略掉次要的属性，而将主要的精力放在重要的属性上。在我们设计的球员类上，对外部程序来说，类名是可见的，但是类的内部信息比如如何实现停球，传球则是要隐藏的。学术一点叫数据封装与信息隐藏。\n现代只要号称支持面向对象的语言都会提供数据封装与信息隐藏的机制，包括Java。只是不同的编程语言支持的方式有些许不同，但是总体来说，都没有超过上一小节中讲的Simula语言所规定的范围。接下来，把数据封装和信息隐藏分别再讲一下。\n\n4.2.1 数据封装\n在讲数据封装以前，我们先考虑这样一件事，如果没有数据封装，我们应该如何写软件？比如游戏中的一个球员，在处理的时候，我们要分别处理每一项属性，比如身高、国籍、球衣号码还有各种球员的动作等等。\n数据封装的意思就是把这些乱七八糟的东西，封装好了，只传递一个对象过来。\n目标是明确的，但是具体到实现上，就有各种各样的问题。不同的语言针对这些问题分别给出了自己的解决方案，本书在后面的章节中将会详细的介绍Java对这些不同问题所采用的取舍。\n在Java中采用的是和C++语言相似的方式来定义类，都是用的class。但是在对象的分配与引用，是否回收上有些许的不同。\n\n\n4.2.2 信息隐藏\n当数据都被封装起来以后，为了提高可靠性，不管是有意还是无意，我们都不能让用户通过随意的方式修改里面的内容。如果要修改，只能通过我们允许的方式来修改，这就是信息隐藏。\n黑箱操作在现实中一般不是好事，但是在面向对象编程中，把对象包装成黑箱是非常好的方法。这样的好处非常多，比如可以限制变动的影响范围，可以在黑箱内部修改数据结构或者方法，而无需修改调用程序本身。还可以“使用我们允许的方式”监视数据的使用，这样会促使我们思考类中的数据是否应该是全局的？在Java编程之中，我们会经常发现，“全局数据”其实是某个对象的数据。\n具体到我们的球员类，我们不会想让外部的程序随意更改对象的名字，比如把Messi改成Ronaldo。同时，我们又想让一些属性可以通过我们允许的方式被修改，比如更改场上的位置，有些球员可以踢前锋，也可以踢中场，这是可以修改的。基于这种要求，Java也提供了相应的机制，字段是私有的（private）还是公有的。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#继承-1",
    "href": "chapter3.html#继承-1",
    "title": "第3章 面向对象编程",
    "section": "4.3 继承",
    "text": "4.3 继承\n每个球队中都有一个场上队长，像梅西目前担任球队的队长，布教授是球队的副队长。从编程角度来看，队长和普通球员绝大部分属性是一样的，在球场上，队长会戴个队长的袖标。当把队长换下场的时候，有时候会出现一个过场动画，会有球员把队长袖标戴给副队长戴上，在玩游戏的时候，我会为这种细节感动。\n队长类和球员类几乎是一样的，虽然直接把球员类拿过来是不行的，但是只要把球员类稍微的做一下修改，那就可以了。这时候又产生了一个问题，我们刚刚讲过，类要保证数据封装和数据隐藏，如果直接修改源码的话，修改人员要了解球员类的代码，才能做出修改，这很困难。为此，Java引入了继承的机制来解决这个问题。\n在编程中，如果新的类（比如队长类）可以继承已有的类（比如球员类）的数据和功能，而且新的类可以允许对原有的类增加或者修改一些内容，那么复用将会变得更加便利。用这种方法，程序员就可以从已经完成的类开始，修改得到其子类型，满足新的要求。这还能理顺类之间的关系，队长也是球员，两个类之间是父子关系，球员类是父类，队长类是子类。\n我们要给队长加个行为：挑边。挑边的意思是开场前，主裁判会扔个硬币，两队队长会根据硬币的正反来选择进攻的方向。按照前面的理论，只要有个机制确保能继承球员类即可。示意图如下：\n\n在这里，先有个概念即可，在实际的编程中，继承并不是这么单纯，实现继承的策略也不像这个例子中这么清晰。目前先不用担心这些细节，在第9章开始，我们再来一起学习Java提供的继承机制。\n从理论上来说，继承可以从多个父类中继承，这种叫单继承；也可以从单个父类中继承，这种叫多继承。不同的语言在这个地方有所取舍，Java采用了一种较为简单的方式，只支持单继承。这样虽然简单，同时也失去了多重继承的优点，为了弥补这种缺点，Java语言实际上可以借助接口（Interface）来实现多重继承的功能，这个在以后的章节我们一起学习。\n\n4.3.1 继承的缺点\n继承的好处我们讲了好多了，再讲点继承的缺点。\n前面讲了类的优点，可以把数据封装起来，还可以隐藏信息。但是过度的使用继承，会导致有多层的继承树，这样编程风格的代码，处理起来非常困难。假设我们有这样一个类，由多层继承而来，该类中有一个方法。如何找到这个方法最初的定义位置呢？没有好办法，只能先查父类，如果没有，再查父类的父类……就算查到了，也不敢贸然修改，因为不确定这个类影响的范围有多广，如果修改了这种类，一定要用一种叫回归测试的方法进行广泛测试。\n\n\n\n\n\n\n回归测试是什么？\n\n\n\n回归测试是指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。自动回归测试将大幅降低系统测试、维护升级等阶段的成本。\n\n\n总之，凡事要有个取舍，我在工作中读过10来层的继承代码，理解起来非常难。尽量兼顾代码的复用度和代码的清晰度。",
    "crumbs": [
      "Java编程",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter4.html",
    "href": "chapter4.html",
    "title": "第4章 变量",
    "section": "",
    "text": "人生若只如初见，何事秋风悲画扇。\n等闲变却故人心，却道故人心易变。\n在这个宇宙中，易变的可不止人心，而是一切。留不住时间，于是年龄会变。保不住新鲜，于是爱人会变。纹身店里，热恋时，胸前纹“一生最爱某某某”有多爱，分手后，用激光清理这些爱的“垃圾”，就有多恨。有办法么？有倒是有的，就是把“一生最爱”纹在身上，后面的“某某某”，用纹身贴纸即可。“一生最爱”是常量，而这个“某某某”就是本章要讲的变量。\n在编程中，变量有很多条条框框，比如，要有个名字，叫变量名。在软件开发领域很有影响力的Martin Fowler，敏捷软件开发的大神，在2009年7月14日曾经发过这样一条推，内容如下：There are only two hard things in Computer Science: cache invalidation and naming thins —— Phil Karlton。这句话翻译成中文是：“在计算机科学只有两件最难的事，缓存失效和变量命名。 – Phil Karlton”\n起初我觉得Phil Karlton的这句话是玩笑，但是后来想了一下，并不是玩笑。在编程中我们可没有那么多玩笑，给变量命名真的很难。\n在构建代码的过程中，最基本的构建活动是如何使用变量。要理解变量，一要像门卫一样问变量三个问题：“你是谁？”“从哪里来？”“到哪里去？”。\n在《西游记》的第八十二回《姹女求阳 元神护道》这一章里，有这样一段：\n这段描写里，八戒的回答相当于什么都没有回答，他既没有回答他从哪里来，又没有回答他向哪里去，又没有回答他是什么名字。仔细想来，我们很多时候都是八戒，好像是明白了，实际上什么都没说，什么也不知道。在学编程的时候，我们不能就这么糊弄过去，一定要搞清楚变量的来龙去脉。",
    "crumbs": [
      "Java编程",
      "第4章 变量"
    ]
  },
  {
    "objectID": "chapter4.html#footnotes",
    "href": "chapter4.html#footnotes",
    "title": "第4章 变量",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n这篇文章的pdf文件我也放在xueban.app这个社区中了。↩︎"
  },
  {
    "objectID": "chapter3.html#在这篇论文中他强调强调由于软件的复杂性本质而使真正的银弹并不存在所谓的没有银弹是指没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍",
    "href": "chapter3.html#在这篇论文中他强调强调由于软件的复杂性本质而使真正的银弹并不存在所谓的没有银弹是指没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍",
    "title": "第3章 面向对象编程",
    "section": "3.4 在这篇论文中他强调强调由于软件的复杂性本质，而使真正的银弹并不存在；所谓的没有银弹是指没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍。",
    "text": "3.4 在这篇论文中他强调强调由于软件的复杂性本质，而使真正的银弹并不存在；所谓的没有银弹是指没有任何一项技术或方法可使软件工程的生产力在十年内提高十倍。",
    "crumbs": [
      "Home",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter3.html#其中银弹silver-bullet的来历是在欧洲民间传说及19世纪以来哥特小说风潮的影响下银弹往往被描绘成具有驱魔功效的武器是针对狼人等超自然怪物的特效武器后来也被比喻为具有极端有效性的解决方法作为杀手锏最强杀招王牌等的代称",
    "href": "chapter3.html#其中银弹silver-bullet的来历是在欧洲民间传说及19世纪以来哥特小说风潮的影响下银弹往往被描绘成具有驱魔功效的武器是针对狼人等超自然怪物的特效武器后来也被比喻为具有极端有效性的解决方法作为杀手锏最强杀招王牌等的代称",
    "title": "第3章 面向对象编程",
    "section": "3.5 其中银弹（Silver Bullet）的来历是：在欧洲民间传说及19世纪以来哥特小说风潮的影响下，银弹往往被描绘成具有驱魔功效的武器，是针对狼人等超自然怪物的特效武器。后来也被比喻为具有极端有效性的解决方法，作为杀手锏、最强杀招、王牌等的代称。",
    "text": "3.5 其中银弹（Silver Bullet）的来历是：在欧洲民间传说及19世纪以来哥特小说风潮的影响下，银弹往往被描绘成具有驱魔功效的武器，是针对狼人等超自然怪物的特效武器。后来也被比喻为具有极端有效性的解决方法，作为杀手锏、最强杀招、王牌等的代称。",
    "crumbs": [
      "Home",
      "第3章 面向对象编程"
    ]
  },
  {
    "objectID": "chapter4.html#基本数据类型",
    "href": "chapter4.html#基本数据类型",
    "title": "第4章 变量",
    "section": "3.1 基本数据类型",
    "text": "3.1 基本数据类型\n在 Java 编程语言中，基本数据类型是构建程序逻辑的基石。它们是最底层、最基础的数据结构，用于直接存储不可分割的原始值，而非引用其他对象或数据结构。\n这些基本数据类型的变量在内存中占用固定大小的空间，并且在声明时就确定了其存储的内容类型和范围，访问速度快。因此，在处理大量简单数据或者对性能要求较高的场景中，选择合适的基本数据类型对于程序的效率和性能至关重要。\n前文已经提到，Java中共有8种基本数据类型，对这8种基本数据类型，可以分为以下4类来学习：整数类型、浮点数类型、字符类型以及布尔类型。\n\n3.1.1 整数类型\n整数类型包括byte、short、int、long，分别对应不同的字节长度和数值范围。\nbyte 占用1字节，取值范围为-128至127\nshort 占用2字节，取值范围为-32,768至32,767\nint 占用4字节，取值范围为-231至231-1\nlong 占用8字节，取值范围为-263至263-1\n在进行整数运算时，尤其需要警惕潜在的溢出风险。当计算结果超出目标整数类型的取值范围时，系统将无法正确存储该结果，进而引发溢出现象。需要注意的是，Java 语言并未内置自动检测和处理整数溢出的功能，这意味着程序员在实现涉及整数运算的代码段时，务必谨慎对待可能发生的溢出问题。\n接下来，我们将通过如下代码示例展示 Java 整数的溢出风险以及溢出后 Java 所采用的处理方式。\npublic class OverflowExample {\n    public static void main(String[] args) {\n        // Java中int类型的范围是-2^31到2^31-1\n        int maxInt = Integer.MAX_VALUE; // 最大整数值 2147483647\n        System.out.println(\"整数所能表示的最大值为: \" + maxInt);\n\n        // 当尝试加上一个正值时，会发生溢出\n        // 输出结果将是 -2147483648，因为发生溢出，数值从整数的最大值回到了最小值\n        int overflowedValue = maxInt + 1;\n        System.out.println(\"最大值上加1之后，会得到： \" + overflowedValue);\n\n        int minInt = Integer.MIN_VALUE; // 最小整数值 -2147483648\n        System.out.println(\"整数所能表示的最小值为: \" + minInt);\n    }\n}\n上面的代码运行之后，输出结果如下：\n整数所能表示的最大值为: 2147483647\n最大值上加1之后，会得到： -2147483648\n整数所能表示的最小值为: -2147483648\n在这个示例程序中，我们首先获取 int 类型的上限值，并将其打印输出到终端。随后，我们尝试将这个已知的最大值加 1。由于这个操作会导致结果超出 int 类型的有效范围限制，因此系统会发生整数溢出。这意味着计算后的结果会循环回绕到 int 类型的下限，即最小可能值。\n这种处理机制被称为回绕（wrap-around），指的是当数值超出某个数据类型的表示范围时，会回绕到该数据类型的最小值。例如，当一个 int 类型的变量超过其最大值时，它会 “回绕” 到 int 类型的最小值，就好像数字在一个圆环上循环一样。\n在编程时，选择合适的整数类型对于提高代码效率和可读性至关重要。因此，我选择整数类型的策略是：在没有特殊需求或明确目的的情况下，优先选择 int 类型作为默认的整数数据类型。接下来，我将深入剖析这一原则背后的原因。\n前文提到，Java 虚拟机 (JVM) 具备一套全面的指令集体系，涵盖了诸如算术运算、逻辑操作、比较判断、存储器管理以及控制流程等多方面的指令。这套指令集能够处理包括 int、long、float、double、boolean 和 char 在内的多种基本数据类型的运算。然而，值得注意的是，对于 byte 和 short 这样的较小整数类型，JVM 并没有特地设计单独的操作码来进行直接处理。\n相反，为了简化指令集的设计结构，并提高代码执行效率，JVM 采用了隐式类型提升机制。当遇到 byte 或 short 类型的变量参与运算时，JVM 会先将这些值自动转换为int类型，然后再运用通用的 int 类型操作指令来执行实际操作。换句话说，虽然 byte 和 short 没有专门的操作码，但它们在运算时会被 “提升” 为 int 类型，从而保证了指令集的简洁性和统一性，并在性能上实现了优化平衡。\n既然在 Java 运算过程中，byte 和 short 类型的变量都会被自动提升至 int 类型进行操作，那么为什么不从一开始就只保留 int 类型呢？当然，在特定场景下，这种“一步到位”的做法并不总是最优解。例如，在对存储空间要求极为苛刻的情况下，选择 byte 或 short 能够显著地压缩数据尺寸，从而发挥关键作用。特别是在处理图像像素数据、网络传输等需要大量紧凑存储和高效传输的领域中，byte 类型和 short 类型的数据类型都有其独特的价值和必要性。\n\n\n3.1.2 浮点数类型\n在Java编程语言中，存在两种浮点数类型：\nfloat：单精度浮点数类型，占用4字节（共计32位）内存，其数值范围大致从3.4e-038到3.4e+038，能够提供大约6到7位的可靠有效数。由于其较小的内存占用，float类型适用于对精度要求相对不高且需节省存储资源的应用场景。\n\n\n\n\n\n\nNote\n\n\n\n3.4e-038 表示的是 3.4 乘以 10 的负 38 次方，即小数点向左移动 38 位。这是 float 类型的最小正数值，接近于 0。3.4e+038 表示的是 3.4 乘以 10 的正 38 次方，即小数点向右移动 38 位。这是 float 类型的最大正数值。\n\n\ndouble：双精度浮点数类型，占用8字节（共计64位）内存，数值范围大致为1.7e-308到1.7e+308，并能确保大约15到16位的有效数字精度。由于更高的精度表现，double通常被推荐为默认的浮点数类型，在不考虑特殊内存约束或精确度需求的情况下应优先使用。\n\n\n\n\n\n\nNote\n\n\n\n1.7e-308 表示的是 1.7 乘以 10 的负 308 次方，即小数点向左移动 308 位。这是 double 类型的最小正数值，接近于 0。1.7e+308 表示的是 1.7 乘以 10 的正 308 次方，即小数点向右移动 308 位。这是 double 类型的最大正数值。\n\n\n这两种浮点数类型 (float 和 double) 均支持正负数表示，并且它们在实际存储时都遵循 IEEE 754 标准。这意味着它们无法准确表示所有实数，尤其是那些不能被精确转换成二进制分数的十进制数。\n之所以会有精度损失的问题，是因为计算机内部采用二进制来表示数字。由于十进制小数并非都能精确转换为有限长度的二进制小数，这导致了部分十进制浮点数在计算机内只能近似表示。例如，十进制的 0.1 无法用二进制精确表示，因此在计算机中存储和计算时会产生微小的误差。\n当涉及到比较两个浮点数是否相等时，由于上述精度损失的存在，直接使用等于运算符 “==” 来进行比较可能会得到意外的结果。例如，两个理论上应该相等但实际上由于浮点计算过程中产生的微小误差而变得不完全相等的浮点数，用 “==” 比较将返回 false。为了正确地比较两个浮点数是否足够接近以被认为是相等的，通常采用的方法是设定一个合理的误差范围（也称为 epsilon 值），并检查两者之差的绝对值是否小于这个误差阈值。\n接下来，我们将通过示例演示浮点数存在的问题以及解决方法，代码如下所示：\nimport java.math.BigDecimal;\n\npublic class FloatingPointPrecisionDemo {\n    public static void main(String[] args) {\n        // 演示浮点数表示不精确\n        float a = 0.0001f, b = 100000.0f;\n        // 输出可能不是预期的100000.0001\n        System.out.println(\"直接加法结果: \" + (a + b));\n\n        // 使用误差范围（epsilon）进行浮点数比较\n        float x = 0.1f, y = 0.10000001f;\n        boolean areAlmostEqual = Math.abs(x - y) &lt; 0.00001f;\n        System.out.println(\"使用误差范围判断是否相等: \" + areAlmostEqual);\n\n        // 在金融应用中建议使用 BigDecimal 类\n        BigDecimal amount1 = new BigDecimal(\"1234.56\");\n        BigDecimal amount2 = new BigDecimal(\"789.01\");\n\n        BigDecimal sum = amount1.add(amount2);\n        System.out.println(\"精确的货币计算结果: \" + sum);\n    }\n}\n运行之后，结果如下：\n直接加法结果: 100000.0\n使用误差范围判断是否相等: true\n精确的货币计算结果: 2023.57\n在计算机编程中，浮点数类型的累积误差是指在进行一系列浮点数运算过程中，由于浮点数的表示方式和精度限制，导致最终结果与理论预期值之间产生的偏差。特别是对于那些不能精确表示为二进制分数的十进制数，在进行加减乘除等连续运算时，每一步计算都会引入一些微小的舍入误差。这些误差在单次运算中可能非常微小，几乎可以忽略不计，但随着计算步骤的增加，这些误差会逐渐累积起来，从而可能导致最终结果与实际期望值有较大的差异。这个问题在需要高精度计算的领域，如金融、科学计算等，尤为重要。\n接下来，我将通过一个例子来解释浮点数类型的累积误差问题。\n美国政府问责局（Government Accountability Office，GAO）曾发布过一份官方文件，其中披露了在1991年2月25日海湾战争期间发生的一起重大事件。这份报告指出，爱国者导弹防御系统遭遇了一次关键性失误，未能成功拦截一枚飞毛腿导弹，导致该导弹击中一处美军营房并造成 28 名士兵不幸丧生的悲剧。\n\n\n\n\n\n\nNote\n\n\n\n这篇报告名为《Roundoff Error and the Patriot Missile》，我已经放到xueban.app上了，该报告详细讲了事故原因。\n\n\n针对这一事件，专家 Robert Skeel 撰写了一份深度剖析报告。报告显示，爱国者导弹防御系统内部计时机制的设计缺陷是此次失效的核心原因。具体来说，由于计算机处理浮点数计算时无法避免微小的精度误差，该系统的计时精确度每经过 8 小时会产生约 0.0275 秒的累积偏差。截至事故发生之时，该系统已连续运行了整整 100 个小时，累计产生了大约 0.34375 秒的时间差错。\n值得注意的是，飞毛腿导弹以高达 5 马赫的速度飞行，即每秒钟可以飞行约 1.7 公里。因此，这看似微不足道的 0.3 秒多的时间误差，在实际操作中却相当于让导弹飞行了约 600 米的距离，足以使其绕过原本应能拦截到的防线。正是这微小的精度损失，最终导致了这场重大灾难性后果。\n爱国者导弹防御系统失误的案例，仅仅是计算机在执行浮点数运算时的常规 “差错” 的一个缩影。计算机在执行涉及浮点数运算的任务时，由于其二进制表示机制、精度限制以及标准化浮点数格式（如 IEEE 754）的设计特性，产生 “小差错” 是必然的结果。这些看似微不足道的 “小差错”，提醒着我们计算机并非精确无误的工具，也激发着我们深入探究计算机如何处理数字的核心领域 —— 小数计算。\n对计算机如何处理小数的历史进行深入探究，或许对实际编程没有直接的指导意义，但这段历史对于编程爱好者而言却充满了魅力。因此，我决定将关于计算机如何处理小数的历史附于下面，当作补充阅读材料，以飨那些对此怀揣好奇的读者。\n\n\n\n\n\n\n计算机中小数处理的历史\n\n\n\n当前，计算机科学中广泛采用的 IEEE 754 标准为大多数计算平台提供了表示带有小数部分的实数的方法。在 Java 编程语言中，我们所熟知的 float 数据类型名称源于 “floating-point” 这一术语，意指浮点数；而 double 类型的命名则因其精度大约是 float 类型两倍的特点而来。\n提及浮点数，人们自然会联想到其对应的 “定点数 (fixed-point)”。事实上，确实存在定点数这一概念，并且了解了定点数之后，对于浮点数的理解将更为轻松和直观。\n接下来，我将详细介绍定点数是什么，以此作为理解浮点数的一个重要铺垫。\n定点数\n定点数（fixed-point numbers）是一种用于表示小数的方法，通过将数值分成整数部分和小数部分来实现。这种表示方式在嵌入式系统、DSP（数字信号处理）以及一些低功耗或性能受限的计算环境中尤为常见，因为这些环境可能不支持浮点运算，或者浮点运算的开销较高。类似地，在金融与商业领域，使用定点数可以有效的减少二进制与十进制转换的误差。\n定点数通常采用固定长度的二进制位模式来编码数据，其中分配给整数和小数的位数均预先设定好。例如，在一个16位的定点数格式中，可以将其划分为8个整数位和8个小数位，小数点则始终固定于第8位（从低位数算起）。定点数的表示方法有多种，比如在数字信号处理领域中采用的Q格式表示法，在金融与商业领域，会用到BCD码的方式。接下来，我详细介绍一下BCD（Binary-Coded Decimal，二进制编码的十进制）码的表示方法。\n以下是BCD码的具体表示规则：它用四位二进制数精确对应十进制数的一个数字，两者之间有一一对应的转换关系，如下表所示:\n\n\n\n十进制数字\n二进制数字\n\n\n\n\n0\n0000\n\n\n1\n0001\n\n\n2\n0010\n\n\n3\n0011\n\n\n4\n0100\n\n\n5\n0101\n\n\n6\n0110\n\n\n7\n0111\n\n\n8\n1000\n\n\n9\n1001\n\n\n\n由上面的对应表可知，每个十进制数对应4位二进制数字。如果要表示一位十进制数8，则可以用1000来表示，如果要表示两位十进制数10，则要分别表示1和0，其中的1表示为4位二进制0001，0则表示为4位二进制 0000。可以把两个十进制数字放一个8位二进制中，正好一个字节中，这种把两个十进制放入一个字节的方法被称之为压缩BCD（packed BCD）。那么十进制数字10用压缩BCD的方式表示为00010000。\n以日常生活中去超市为例，我们会经常看到商品的标价为19.99元、9.99元这样的价格。在超市场景下，计价系统的小数位事先确定为两位小数，也就是精确度保留到分即可。假设我开了一家超市，要处理的账目是±1000万，精度精确到分，这意味着系统可以表示如下范围的数字：-10,000,000.00元到 +10,000,000.00元。\n当我要表示一笔3,898,190.25元的记录，可以从最后开始，以两位十进制数字为单位进行拆分，写成如下的方式：\n\n\n\n3\n89\n81\n90\n25\n\n\n\n\n00000011\n10001001\n11000001\n10010000\n00100101\n\n\n\n定点数因其固有的特性，在特定应用场景下具有一些优势：其固定的数值表示形式使得存储空间需求更小，同时避免了复杂浮点运算的开销。然而，这种数据类型也存在局限性，即其数值范围和精度是预先设定且不可变的，无法根据实际需求进行灵活调整。若已知待处理的数据具有明确的数值边界，则采用定点格式的小数无疑是明智之举，它能够确保在预设范围内不会出现意外的精度误差。\n在Java的标准库中，并未直接提供对定点数类型的内建支持，而是侧重于原生支持浮点数类型，如float和double。尽管浮点数类型的计算速度可能相对较低，并且在某些情况下会出现一定的精度损失，但它们具备比定点数更高的精度水平以及更为宽广的数值表示能力。接下来，我们一同深入探讨Java中的浮点数类型的机制。\n浮点数\n在讲浮点数之前，先来讲一下如何用二进制表示小数。在计算机中，小数可以使用二进制表示法来存储和处理。二进制小数表示法基于科学计数法，将小数部分转换为二进制数，并使用科学计数法的形式来表示数值。\n将十进制小数转化为二进制小数的步骤如下：\n\n将小数部分乘以 2，得到积和整数部分。\n将积的整数部分作为二进制数的一位，并将小数部分保留。\n将小数部分重复第 1 步和第 2 步，直到小数部分为 0 或达到所需的精度。\n\n例如，将十进制小数0.625转化成二进制小数的过程如下：\n0.625 × 2 = 1.25，整数部分为 1，小数部分为 0.25\n0.25 × 2 = 0.5，整数部分为 0，小数部分为 0.5\n0.5 × 2 = 1.0，整数部分为 1，小数部分为 0\n因此，0.625 的二进制表示为 0.101。\n那如何将二进制小数转换为十进制小数呢？其方法与将整数从十进制转换为二进制的方法类似，只不过需要将每一位的权值改为 2-n，其中n表示该位在二进制数中的位数。以下是将二进制小数转换为十进制小数的方法：\n\n将二进制小数的整数部分和小数部分分别转换为十进制数。\n对于小数部分，将每一位的权值改为 2-n，其中n表示该位在二进制数中的位数。\n将小数部分的每一位乘以对应的权值，并将所有结果相加，得到十进制小数的值。\n\n举个例子，以110.1101这个带有小数点的二进制数为例，\n\n当我们在表示一个很大的数的时候，比如美国国债是$25,000,000,000,000，数学上会采用科学计数法来计数，写成这样：2.5 × 1013。在科学计数法中，我们称2.5为首数，10的幂是13，我们称13为指数。在计算机中也类似，只是给首数改了个名字叫有效数，指数没改名字，还是叫指数。\n当我们看到2.5 × \\(10^{13}\\)的时候，知道把小数点向右移动13位，当看到4.5 × \\(10{-3}\\)的时候，把小数点向左移动3位成为0.00045。因此只要知道了指数，就知道怎么浮动小数点了，指数是正的就向右移，指数是负的就向左移。这就是浮点数的基本原理了，小数点浮动的方向和浮动多少，都由指数决定。 浮点数还有一个规定叫写法的规范化，什么叫规范化呢？还是以美国的国债为例，可以写成2.5 × \\(10^{13}\\)，虽然写成25 × \\(10^{12}\\)、250 × \\(10^{11}\\)都可以理解，但是后面这两种不规范。对十进制来说，规范化是规定有效数只能介于0和10之间。对二进制浮点数来说，规范化的写法第一位只能是1。以110.1101为例，规范化的二进制浮点数只能是1.101101 × \\(2^2\\)这一种形式，其余的形式都是不规范的。\n因为规范化的二进制浮点数第一位永远只能是1，所以根本就没必要存储这一位。因此，对实数来说，IEEE 754规定，只需要存储三个信息即可：代表正负的符号位、代表如何浮动小数点位置的指数和有效值。以IEEE定义的4个字节的float单精度格式为例。\n\n\n\nIEEE 754规定的单精度浮点数float\n\n\n长度为1位的符号位s代表正数还是负数，0表示正数，1表示负数。\n随后的8位是指数位e，8位可以代表0到255的数值。在此，我们取1到254，0和255留作他用。小数点有可能向左浮动，也有可能向右移动，我们规定这个数减去127，正好可以左移或者右移，此处的 127我们称之为偏移量。\n接下来是23位有效数f，前面已经讲过，有效数的第一位永远是1，所以不用存这一位，只需要在计算的时候补上这个1即可。综上，这个特定的数可以用这个公式来计算：\n\\((-1)^s × 1.f × 2^{e-127}\\)\n还有几种特殊情况要单独考虑，比如指数位都是0或者都是1的时候，这也是为什么指数位要保留了0和255两个数用作其它用途的原因，表示无穷大（Positive Infinity），无穷小（Negative Infinity）或者不合法NaN（Not a Number），比如当0/0时或者对一个负数进行平方根操作会返回不合法。这三种情况在实际应用中并不多见，Java为其提供了相应的常量分别是Float.POSITIVE_INFINITY、Float.NEGATIVE_INFINITY和Float.NaN（相应的double类型也有这三个常量）。\n接下来我们来看看单精度浮点的表示范围，理解了原理，套用上面的公\\((-1)^s × 1.f × 2^{e-127}\\)，我们知道绝对值最小的正负二进制是：\n\\((-1)^s x (1.00000000000000000000000)_2 × 2^{-126}\\)\n指数位为\\((1)_{10}\\)，也就是让小数点移动到最左侧，有效值是一个1，后面跟23个0。这个数用十进制表示，近似的等于±1.17549435 × \\(10^{-38}\\)。最大表示的数是:\n\\((-1)^s x (1.11111111111111111111111)_2 × 2^{-127}\\)\n指数位为\\((254)_{10}\\)，让小数点移动到最右边。有效值为24个1。这个数如果用十进制表示的话，近似的等于±3.40282347 × \\(10^{38}\\)。所以，只要是用IEEE 754规定的浮点数，float类型的取值范围是 ±1.17549435 x \\(10^{-38}\\) 到 ±3.40282347 × \\(10^{38}\\)。\n以上就是单精度浮点数的原理，双精度浮点数的原理跟单精度浮点数类似，不再赘述。\n\n\n\n\n3.1.3 字符类型\n在 Java 语言中，字符类型作为一种基础数据类型占据着重要地位，它专门用于处理单个字符信息。每个 char 变量占用两个字节（16 位）的空间，并采用 Unicode 字符集进行编码处理，确保能够表示全球范围内的多种语言和特殊符号。\n接下来，我们将通过示例详细展示 字符类型的常见用法，包括声明、初始化、比较、类型转换以及在字符串处理中的应用，\npublic class CharExample {\n    public static void main(String[] args) {\n        // 声明并初始化一个字符类型的变量\n        char myChar = 'D';\n\n        // 输出字符\n        System.out.println(\"myChar这个字符是: \" + myChar);\n\n        // 使用字符类型进行比较操作\n        char anotherChar = 'B';\n        if (myChar == anotherChar) {\n            System.out.println(\"两个字符相同.\");\n        } else {\n            System.out.println(\"两个字符不同\");\n        }\n\n        // 将ASCII码转换为字符类型\n        // ASCII值对应字符'D'\n        int asciiValue = 68;\n        char charFromAscii = (char) asciiValue;\n        System.out.println(\"ASCII为68的字符为：\" + charFromAscii);\n\n        // 使用字符类型进行字符串处理\n        String name = \"Alice\";\n        char firstLetter = name.charAt(0);\n        System.out.println(\"字符串的第一个符为: \" + firstLetter);\n    }\n}\n这段代码展示了如何声明和初始化char变量，并进行简单的字符比较；同时演示了如何将Unicode码（这里是ASCII码）转换为字符类型，以及如何从字符串中提取首个字符。\n在计算机科学领域，正确理解和处理字符是一项充满挑战却又饶有趣味的事情，在编程发展史上经历了相当长的一段时间。为了让有兴趣的读者深入了解这段历史脉络，我特地撰写了关于计算机中字符处理发展的历史。\n\n\n\n\n\n\n计算机中字符处理的历史\n\n\n\n在人类文明的长河中，信息传递与记录方式的发展始终伴随着科技进步的步伐。自古至今，从刻划在泥板上的楔形文字、镌刻在龟甲和兽骨上的甲骨文、书写在竹简上的汉字到印刷术的诞生，字符的记载形式不断演变。随着20世纪计算机技术的崛起，如何让冰冷的机器理解并处理人类语言中的字符，成为了一项至关重要的挑战。早期的计算机系统受限于硬件条件和编码体系的不统一，对字符的识别和处理存在着显著的局限性。\n随着时间的推移，从博多码到ASCII码，再到Unicode的提出，每一步都是人类智慧在解决字符编码问题上的一次飞跃。这些编码方案不仅反映了计算机科学的进步，也揭示了全球化时代下文化交融与交流的需求。这段历史见证了字符编码从单一语言向多元文化的包容性转变，同时也为现代计算机系统提供了坚实的语言基础支持。在这段旅程中，我们将会探讨一系列里程碑式的字符编码标准及其背后的故事，从而深入理解计算机是如何逐步“学会”理解和处理各种字符的。\n博多码\n在看电影时，我们有时会目睹演员用手电筒发出闪烁的灯光以传达SOS求救信号的情节，这种编码方式是源自于约1836年由塞缪尔·摩尔斯发明的摩尔斯码。作为一种历史悠久且曾占据主导地位的通信编码体系，摩尔斯码主要用于早期的电报传输，在二十世纪中叶之前扮演了至关重要的角色，直至随着技术进步和新型通信手段的涌现而逐渐淡出主流舞台。\n博多码是在摩尔斯码之后出现的，是在1870年由法国工程师爱米尔·博多（Emile Baudot）发明的一种二进制编码体系。该编码系统巧妙地运用了5位二进制数来表示单个字符，从而理论上能够表达出2的5次方即32种不同的组合。为了扩展字符集，博多码引入了两种工作状态：字母状态和数字状态，使得在有限的32种组合内能够表示更多的字符。在字母模式下，这套编码被用来表示字母及特定符号；而在数字模式时，则用于呈现数字和其他相关符号。\n博多码自发明后得到了广泛应用，尤其是在电报通信与早期电传打字机技术中发挥了重要作用。尽管随着时间的推移，它已被更先进的编码方式所取代，但博多码的一项关键设计遗产至今仍深深地影响着我们每一个人的日常生活——即键盘上用于切换字母与数字状态的Shift键。这一设计延续至今，已经成为了现代计算机输入设备不可或缺的一部分。\n历经以电传打字机为代表的电传通信网络二十年的发展与积淀，历史迈入了全新的计算机时代。1949年，具有里程碑意义的EDSAC计算机应运而生，这款计算机在字符编码上采用了名为EDSAC编码的方案。这一编码体系深受博多码的影响，同样采取5位二进制形式来表示一个字符，并沿用了博多码中用于切换字母与数字状态的关键设计——Shift键。\nEDSAC计算机诞生后的十年间，计算机技术蓬勃发展，各类新型计算机如雨后春笋般涌现，然而这些计算机在字符编码方面并未形成统一标准，每种型号的计算机均有各自独特的编码体系。这一现象导致了不同型号计算机之间数据交流的严重障碍，它们无法直接识别和处理彼此的数据信息，必须通过繁琐且容易出错的编码转换过程才能实现有效的数据交互，极大地限制了当时计算机系统的互操作性和数据共享效率。\nASCII码\n鉴于当时计算机领域对于统一字符编码标准的迫切需求，IBM的一位名叫Bob Bemer的员工于1961年向美国国家标准学会（ANSI）提出了ASCII编码方案。ASCII全称为American Standard Code for Information Interchange，即信息交换的美国标准代码，这一名称清晰地表达了其旨在消除不同计算机系统间信息交流障碍的初衷。\n在提出后的两年内，ANSI采纳并发布了首个ASCII编码标准版本。随着技术发展和应用需求的变化，ASCII编码历经了多个版本的修订和完善。至1972年，ASCII编码已有了一个较为成熟的版本，它为后续的信息科技领域奠定了基础性的文本编码规范，并对全球范围内的计算机通信产生了深远的影响。下图是1972年的ASCII版本。\n\n\n\n1972年发布的ASCII编码表\n\n\n观察上图所示的ASCII编码表不难发现，其主要涵盖了英文字符集以及一系列控制字符。ASCII编码体系采用7位二进制数值对单个字符进行编码，基于这一特性，理论上最多能够表达128种不同的字符形态。这些字符囊括了从0到9的阿拉伯数字、全部26个英文字母（包括大写和小写）、各种标点符号以及其他一些具有特定功能的控制字符，共同构成了计算机处理文本信息的基础字符集合。\n在ASCII编码体系中，每个字符均对应着一个独一无二的数字标识，这些编码可被计算机系统有效地识别和处理。例如，大写字母”A”的ASCII编码为65（其二进制表示形式为01000001），小写字母”a”的编码则为97（对应的二进制码为01100001），数字”0”的编码数值为48（以二进制显示为00110000），而标点符号”!“的编码是33（其二进制表达为00100001）。尽管ASCII编码所能涵盖的字符集相对有限，但其作为计算机编码的基础原理，在文本处理、网络通信等众多领域中依然发挥着不可或缺的作用。\n随着计算机技术的发展以及全球范围内不同语言和符号需求的增长，单一的ASCII编码已无法满足全部需要。因此，人们扩展了ASCII编码体系，发展出了如ASCII扩展字符集1、2和3等多种扩充方案。同时，针对特定语言环境下的字符集，诸如简体中文采用了GB2312编码标准，繁体中文则依赖于Big5编码，俄语则采用KOI8编码机制等。此类编码方式各异，反映出各地区对字符处理的不同需求和复杂性。\nUnicode码\n为了应对全球字符编码的挑战与需求，Unicode方案应运而生，其别称包括统一码、万国码、国际码和单一码等，这些名称无一不揭示了Unicode所承载的伟大愿景——旨在创建一种能够涵盖全世界所有字符的统一编码体系。从这些多元化的翻译中，我们得以窥见Unicode背后宏大的理想与决心，即实现一个能全面囊括各地区语言文字及特殊符号的普适性编码标准。\n1987年，一个雄心勃勃的计划崭露头角，该计划由施乐公司（Xerox）的Joe Becker、苹果公司（Apple）的Lee Collins以及Mark Davis共同发起。他们的愿景是创建一个能够全面覆盖全球主流字符集的统一编码体系。历经精心筹备后，于1988年这一划时代的Unicode标准应运而生，后被人称为“Unicode 88”。\n\n\n\n\n\n\nTip\n\n\n\n1988年的Unicode文档\n1988年发布的Unicode文档的PDF文件我已经放在xueban.app社区中，但是细节实在是太复杂，我只读了一点。之所以叫Unicode，是因为想让这个编码Unique，Unified和Universal。\n\n\n在这部具有里程碑意义的1988年发布的文档中明确阐述了Unicode的核心目标：“旨在以一种切实可行且稳定可靠的方式满足全球范围内对于文本处理的需求。简而言之，Unicode可以被视为ASCII码的宽广扩展版，其字符容量已从最初的范围拓展至16位，从而有能力容纳更丰富多元的语言和符号。”\n让我们进行一个简单的计算，16位二进制所能表示的最大字符数量为216 = 65,536个，其编码范围从U+0000一直到 U+FFFF。在这65,536个字符空间中，涵盖了全球绝大多数主流语言的字符集，诸如拉丁字母、希腊字母、西里尔字母、阿拉伯字母、希伯来字母以及东方文字如汉字、日文平假名和片假名等。\n在Unicode编码规范中，每一个字符都对应着一个独一无二的标识，这个标识被称为码点（Code Point）。而在Java编程语言中，通常采用”前缀紧接着四位十六进制数的形式来表示Unicode码点，例如，“041”代表了拉丁字母”A”的码点，而“80B”则表示的是汉字“栋”的码点。接下来，看一下下面代码的例子：\npublic class UnicodeExample1 {\n    public static void main(String[] args) {\n\n        // 输出拉丁字母“A”的Unicode编码形式\n        char latinLetter = '\\u0041';\n        // 输出：字母： A\n        System.out.println(\"字母： \" + latinLetter);\n\n        // 输出汉字“栋”的Unicode编码形式\n        char chineseCharacter = '\\u680B';\n        // 输出：汉字： 栋\n        System.out.println(\"汉字： \" + chineseCharacter);\n    }\n}\n解释一下上面这段Java代码，这段代码主要用于演示如何在Java中使用Unicode编码表示和输出字符。\n首先，代码声明了一个字符变量latinLetter，并将其赋值为\\u0041。在Java中，\\u开头的序列是一个Unicode转义序列，用于表示一个Unicode字符。\\u0041对应的正是Unicode编码中的拉丁字母”A”（对应ASCII编码中的A）。\n接下来，定义了另一个字符变量chineseCharacter，并将其赋值为\\u680B，这是汉字“栋”的Unicode编码。\n总结来说，这段Java代码通过Unicode编码展示了如何在程序中表示和显示不同语言的字符，无论是拉丁字母还是汉字。通过Unicode编码，Java能够支持全球各种语言和符号的统一表示和处理。\n\n\n\n\n3.1.4 布尔类型\n在 Java 编程语言中，布尔类型被设计用于表示逻辑状态，它具备两种明确且互斥的取值：true 和 false。使用关键字 boolean 声明布尔类型的变量，使得开发者能够在程序中定义和操作代表真假条件的逻辑值。\npublic class BooleanExample {\n    public static void main(String[] args) {\n        // 声明并初始化两个布尔变量，分别表示学生是否完成作业和是否通过考试\n        boolean hasFinishedHomework = true;\n        boolean passedTheExam = false;\n\n        // 使用布尔值进行逻辑判断，并根据结果输出相应信息\n        if (hasFinishedHomework && passedTheExam) {\n            System.out.println(\"完成了作业并通过了考试\");\n        } else if (hasFinishedHomework) {\n            System.out.println(\"完成了作业，但未通过考试\");\n        } else if (passedTheExam) {\n            System.out.println(\"未完成作业，但已通过考试\");\n        } else {\n            System.out.println(\"既未完成作业也未通过考试\");\n        }\n    }\n}\n在这个例子中，我们声明了两个布尔变量 hasFinishedHomework 和 passedTheExam，分别代表学生是否完成了作业以及是否通过了考试。然后，我们使用选择语句 (if-else) 对这两个布尔值进行组合和单独判断，从而决定学生的不同状态及相应的反馈信息。这个简单的示例展示了如何运用布尔值来进行逻辑运算和决策控制，从而解决实际问题。\n布尔类型作为一种相对简洁的基础数据类型，在计算机科学史上扮演着不可或缺的角色。为了让各位读者拓展阅读和深入了解这一重要概念的历史沿革，我将在下面讲一个布尔类型的插曲。\n\n\n\n\n\n\nTip\n\n\n\n布尔类型的由来\n布尔数据类型的概念最早由 ALGOL 60 编程语言在 1960 年开创性地引入。自此以后，它成为了几乎所有后续设计的主流编程语言不可或缺的组成部分。\n值得一提的是，C 语言在其最初的标准化版本 C89（亦称为 ANSI C）中，并未直接提供布尔类型的支持，而是采用了一种约定俗成的方式，即非零整数值代表逻辑真 (true)，而值为 0 则表示逻辑假 (false)。\n直至 1999 年发布的 C 语言更新标准 C99 版本时，通过引入了头文件stdbool.h，正式将布尔类型纳入规范。此举旨在为程序员提供一种更为直观和规范的方式来处理布尔逻辑表达式及其结果。\n有很多语言借鉴了C语言的方法，比如Python、JavaScript。幸好，Java没有采用类似的方式。\n\n\n\n\n3.1.5 类型转换\n在Java编程中，数据类型转换是核心概念之一，它确保开发者能灵活处理八种基本数据类型的数值（如整数类型、浮点型、字符和布尔值），以适应复杂场景。不同类型间赋值时会发生转换：从较小到较大类型会自动进行（如int转long），而从较大到较小类型则需显式指定，并确保不引发精度丢失或溢出问题。\n掌握类型转换对编写高效且稳定的代码至关重要，可避免潜在错误并优化性能。类型转换可以分为两种情况：自动（隐式）转换和强制（显式）转换。接下来，我们将深入解析Java基本数据类型间的转换规则及应用示例。\n自动（隐式）转换\n在Java编程中，自动（隐式）类型转换是一种无需程序员显式指令即可完成的数据类型迁移过程。通常情况下，当两种数据类型之间存在层级关系时，即从数值范围较小的类型向数值范围较大的类型过渡，系统会自动执行此种转换。例如，可以将一个有效值域较窄的数据类型无缝转换为一个可容纳更大数值范围的数据类型，这种转换操作确保了数据精度得以完整保留。如下图所示，实线箭头所指示的方向代表着那些能够保持原始精度不损失的自动类型转换路径。\n\n\n\nJava基本数据类型之间的转换\n\n\n自动类型转换依次遵从如下的规则：\n规则1：如果有一个操作数为double类型，那么先要将另一个操作数转换为double类型\n规则2：如果有一个操作数为float类型，那么先要将另一个操作数转换为float类型\n规则3：如果有一个操作数为long类型，那么将另一个操作数转换为long类型\n规则4：如果以上都不满足，那两个操作数都转换为int类型\n了解了以上四条规则，我们通过几个示例来验证一下这些规则，代码如下所示。\npublic class TypeConversionExample {\n    public static void main(String[] args) {\n        // 规则1：double类型的优先级最高\n        byte b = 5;\n        double d = 10.5;\n        System.out.println(b + d); // b 自动提升为 double 类型\n\n        // 规则2：若有float，其它转换为float\n        int i = 10;\n        float f = 5.5f;\n        System.out.println(i + f); // i 自动转换为 float 类型\n\n        // 规则3：若有long，其它转换为long\n        short s = 2;\n        long l = 20L;\n        System.out.println(s + l); // s 自动提升为 long 类型\n\n        // 规则4：如果都是整数类型（非上述情况），则提升至int\n       byte b1 =120;\n        byte b2 = 120;\n        // 字符类型在运算前会先被转换为int类型\n        System.out.println(b1 + b2);\n    }\n}\n在实际编程中，当进行涉及 char 和 byte、short、int 之间的算术运算时，Java 会自动将其提升至 int 类型，然后再执行运算。此外，在表达式中涉及浮点数时，整数类型会根据规则提升至对应的浮点数类型。例如，如果一个表达式包含 int 和 double 类型的操作数，那么 int 类型的操作数会先被提升为 double 类型，然后再进行计算。\n强制（显式）转换\n在 Java 编程语言中，强制（显式）类型转换是指程序员明确地将一种数据类型转换为另一种数据类型的过程。例如，当试图将一个 double 类型的变量赋值给一个 int 类型的变量时，或者需要将一个 Object 类型的引用转换为 String 类型的引用时，就需要进行强制类型转换。\n基本数据类型，例如整数类型（byte、short、int、long）、浮点数类型（float、double）或字符类型 （char）之间互相转换时，如果目标类型无法自动容纳源类型的值，则必须使用强制类型转换。强制类型转换可能会导致精度丢失或溢出，因此程序员需要谨慎使用，并确保转换后的值在预期范围内。\n为说明情况，我们通过如下代码来验证前面的说法。\npublic class TypeCastingExample {\n    public static void main(String[] args) {\n        // 示例1：long类型转int类型（可能丢失精度）\n        // 下面的largeValue值大于int的最大值\n        long largeValue = Integer.MAX_VALUE + 1;\n        int intValue;\n\n        // 强制类型转换，由于long类型的largeValue超过了int的最大值，\n        // 转换时会丢失精度，转换后的值不是largeValue的值\n        intValue = (int) largeValue;\n        System.out.println(\"long to int: \" + intValue);\n\n        // 示例2：float类型转int类型（同样可能丢失精度和尾数）\n        float floatValue = 123.456f;\n        intValue = (int) floatValue; // 强制转换为整数，会丢弃小数部分\n        System.out.println(\"float to int: \" + intValue); // 输出：123，小数部分被舍去\n\n        // 示例3：安全的类型转换（不丢失数据精度)\n        // byte的最大值是127\n        byte smallByte = 127;\n        // 这种转换是安全的，因为byte的所有值都在short的范围内\n        short smallShort = (short) smallByte;\n        System.out.println(\"byte to short: \" + smallShort); // 输出：127\n    }\n}\n在上面这个例子中，展示了几个不同场景下的强制类型转换：\n\n当尝试将一个超出目标类型表示范围的long值转换为int时，会发生精度丢失，因为int无法完整存储long的大数值。\n将float转换为int时，也会发生精度丢失，因为浮点数的小数部分会被截断，仅保留整数部分。\n在byte与short之间进行安全的转换，不会导致数据丢失，因为所有有效的byte值都能够在short类型中正确表示。\n\n在实际编程中，应该尽量避免可能导致数据丢失的强制类型转换。为了保证数据的完整性和程序的正确性，在进行强制类型转换之前，务必充分理解目标类型的大小和取值范围。",
    "crumbs": [
      "Java编程",
      "第4章 变量"
    ]
  },
  {
    "objectID": "chapter4.html#e-308-表示的是-1.7-乘以-10-的负-308-次方即小数点向左移动-308-位这是-double-类型的最小正数值接近于-01.7e308-表示的是-1.7-乘以-10-的正-308-次方即小数点向右移动-308-位这是-double-类型的最大正数值",
    "href": "chapter4.html#e-308-表示的是-1.7-乘以-10-的负-308-次方即小数点向左移动-308-位这是-double-类型的最小正数值接近于-01.7e308-表示的是-1.7-乘以-10-的正-308-次方即小数点向右移动-308-位这是-double-类型的最大正数值",
    "title": "第4章 变量",
    "section": "3.2 1.7e-308 表示的是 1.7 乘以 10 的负 308 次方，即小数点向左移动 308 位。这是 double 类型的最小正数值，接近于 0。1.7e+308 表示的是 1.7 乘以 10 的正 308 次方，即小数点向右移动 308 位。这是 double 类型的最大正数值。",
    "text": "3.2 1.7e-308 表示的是 1.7 乘以 10 的负 308 次方，即小数点向左移动 308 位。这是 double 类型的最小正数值，接近于 0。1.7e+308 表示的是 1.7 乘以 10 的正 308 次方，即小数点向右移动 308 位。这是 double 类型的最大正数值。",
    "crumbs": [
      "Home",
      "第4章 变量"
    ]
  },
  {
    "objectID": "chapter4.html#引用数据类型",
    "href": "chapter4.html#引用数据类型",
    "title": "第4章 变量",
    "section": "3.2 引用数据类型",
    "text": "3.2 引用数据类型\nJava中的引用数据类型变量与基本数据类型有着显著的不同。基本数据类型变量直接包含数据，而引用数据类型变量实际上并不直接存储对象本身，而是存储对对象的一个引用，即指向对象所在的内存地址。常见的引用数据类型有类（Class）、接口（Interface）、数组（Array）等。由于该类型的变量涉及内存管理和对象生命周期等更复杂的概念，为了确保讲解的连贯性和理解的深度，我决定将引用数据类型变量的详细讨论延后进行，待大家对类、接口等基础概念更为熟悉后再深入探究这一主题。\n目前，只涉及一些表面的知识，比如，在Java中有如下的两条语句，它们分别用于定义两种不同类型的变量实例：\n    int age1 = 20;\n    Integer age2 = 20;\n这两条声明语句揭示了Java中基本数据类型（如int）与引用数据类型（如Integer）之间的差异。\n首先，int是Java内建的基本整数类型，它直接存储数值，并在栈内存上分配空间，不涉及对象的概念。声明int age1 = 20时，变量age1将占用固定大小的空间来存储值20，且由于其为基本数据类型，无法被赋予null值。\n而Integer则是对基本数据类型int的封装类，属于引用数据类型。当声明Integer age2 = 20时，age2变量实际存储的是一个指向Integer对象的引用，该对象在堆内存中创建并存储数值20。由于Integer是一个对象，它可以具有额外的方法和属性，并且可以赋值为null，这为其提供了更丰富的功能和灵活性，比如自动装箱与拆箱机制、与集合框架的良好兼容性等。\n通过对比上述两条语句，我们可以初步理解Java类型系统中基本数据类型与引用数据类型的基本特征和使用场景，为进一步探究更深层次的编程技术打下坚实的基础。",
    "crumbs": [
      "Java编程",
      "第4章 变量"
    ]
  },
  {
    "objectID": "chapter4.html#java变量的作用域",
    "href": "chapter4.html#java变量的作用域",
    "title": "第4章 变量",
    "section": "4.1 Java变量的作用域",
    "text": "4.1 Java变量的作用域\n在 Java 中，变量的作用域指的是变量在程序中可以被访问的范围，如果在一个作用域内定义了一个变量，它会覆盖外层作用域定义的同名变量，这种情况称为变量遮蔽。无论对人名还是变量来说，朗朗上口的名字比较稀缺，非常容易重名。\n\n\n\n\n\n\n重名问题普遍存在\n\n\n\n《2019年全国姓名报告》报告显示，全国户籍人口中，使用频率最高姓名“张伟”有近30万人。但是这30万“张伟”并没有对我们造成过多困扰。对我们每个人来说，“张伟”是有作用域的。\n更普遍的例子，每个人都有“爸爸”，但是当喊“爸爸”的时候，并没有造成什么困扰，因为“爸爸”这个称呼在家庭这个作用域内是唯一的。当别人喊“爸爸”时，一定要注意作用域。\n\n\n在Java中，变量的作用域取决于它被声明的位置。以下是一个简单的示例代码片段，通过下面代码中的例子可以清晰地展示类成员变量、方法局部变量以及嵌套块级作用域内变量的不同作用域：\npublic class ScopeExample {\n    // 类作用域（类成员变量）：在整个类范围内有效\n    public static int classVariable = 100;\n\n    public void methodScope() {\n        // 方法作用域（局部变量）：只在当前方法内部有效\n        int methodVariable = 20;\n\n        System.out.println(\"Class variable: \" + classVariable);\n        System.out.println(\"Method variable: \" + methodVariable);\n\n        // 块级作用域：只在当前大括号{}内有效\n        {\n            int blockVariable = 30;\n            System.out.println(\"Block variable: \" + blockVariable);\n        }\n\n        // 尝试访问已超出作用域的blockVariable会编译错误\n        // System.out.println(\"从Bolck外部访问\" + blockVariable);\n    }\n\n    public static void main(String[] args) {\n        // 创建一个ScopeExample对象实例\n        ScopeExample example = new ScopeExample();\n\n        // 可以在main方法中直接访问类作用域的变量\n        System.out.println(\"从main中访问类成员变量\" + example.classVariable);\n\n        // 调用methodScope方法\n        example.methodScope();\n\n        // 在main方法中尝试访问methodVariable或blockVariable会编译错误\n        // 因为它们的作用域仅限于各自的方法和块内部\n        // System.out.println(\"从main中访问\" + methodVariable);\n        // System.out.println(\"从main中访问\" + blockVariable);\n    }\n}\n在上述示例代码中，简要涉及了几种不同类型的作用域概念：类作用域（Class Scope）、、方法作用域（Method Scope）以及代码块作用域（Block Scope）。虽然目前尚未对这些作用域名进行详细的阐述，但它们正是后续章节要深入探讨的核心内容。通过逐步解析这些知识的不同特征和适用场景，读者将能够充分理解Java变量在其生命周期内如何受到作用域规则的制约与影响，并学会在实际编程过程中有效地管理和控制变量的范围。\n在给出的代码示例中，我已通过详尽的注释对涉及不同作用域的变量进行了初步解读，并特意标识出那些超出作用域引用导致错误的部分，旨在直观展现变量的作用域这一核心概念。待你深入研读后续章节、系统性地学习之后，再次回顾此部分内容时，定会感到豁然开朗，原本看似复杂的知识点实则变得如此清晰易懂，恰似将厚重的知识体系“化繁为简”、“由厚读薄”的过程。\n若能进一步探究历史上其他编程语言在处理作用域问题上的不同策略与机制，将极大地丰富我们对Java作用域特性的理解，并有助于从更广阔的视角去把握和应用这一关键概念。通过比较不同语言间的作用域设计理念与实践差异，不仅可以加深对Java作用域规则的认识，还能促使我们更好地借鉴前人的智慧，在实际编程过程中更加得心应手地驾驭作用域这一核心要素。接下来，我讲一下作用域的历史。",
    "crumbs": [
      "Java编程",
      "第4章 变量"
    ]
  },
  {
    "objectID": "chapter2.html#jim-gray简介",
    "href": "chapter2.html#jim-gray简介",
    "title": "第2章 Hello World",
    "section": "1.5 Jim Gray简介",
    "text": "1.5 Jim Gray简介\nJim Gray是第三位因推动数据库技术而获得图灵奖的人，在计算机方面有非常多贡献。他爱好冒险，在2007年1月28日，他驾驶着自己40英尺的船，消失在茫茫大海，至今杳无音讯。5年后的2012年1月28日，Jim Gray在法律上被宣告去世。\n我平时还有个爱好是录podcast，名字叫“软件那些事儿”，我录了快500期电台了。有一个系列叫图灵奖得主介绍，就介绍每一年图灵奖得主的信息，如果你有兴趣，可以搜来听听，或者到liuyandong.com上看文字版。"
  },
  {
    "objectID": "intro0.html",
    "href": "intro0.html",
    "title": "前言",
    "section": "",
    "text": "说来惭愧，我本来想出版一本书的，由于诸多原因，书没法出版了。但是有一部分人——主要是电台的听众——帮我修定了书中很多错误，我本来说好会把他们的名字印在纸书上，但是，又食言了。把这些贵人的名字写在这里了，表示抱歉与感谢。下面是“原本的前言”。\n\n\n\n\n\n\n“原本的”前言 :)\n\n\n\n本书旨在为对 Java 编程感兴趣的读者提供入门指南，无论您是希望开发安卓手机应用、网站、还是中间件，都能从中获取重要的基础知识。正如副标题“有趣有料的 Java 编程”所言，本书不仅涵盖了编程语言和编程范式的基础知识，还穿插了大量引人入胜的编程故事，并深入挖掘其背后的历史真相。\n例如，在介绍面向对象编程时，本书用了一定篇幅讲述了世界上首个面向对象编程语言 Simula，并梳理了面向对象编程的发展脉络。在数据类型方面，本书列举了一些因数据类型精度不足而导致的案例，如爱国者防御系统故障，导致一枚飞毛腿导弹命中士兵营房。而在介绍 Java 引入的函数式编程时，则从世界上第一门函数式语言 Lisp 讲起，带领读者认识 Java 函数式编程的优势与不足。\n通过这种将历史与实践相结合的方式，本书不仅阐释了 Java 编程的核心概念，更揭示了编程语言发展背后的故事，希望能为读者带来更深层次的理解和启发。\n我始终认为，学习编程语言的最佳途径之一，便是追溯其发展历史，了解其起源和演变。通过在历史中考证语言的进化轨迹，并在实践中学习编程技巧，我们能够更深入地理解语言发展的脉络，更真切地领会语言设计者的意图。\n关于如何学习编程，我联想到清代文学家彭端淑所写的《为学》一文，这也是很多地方初中必学的古文。文中讲述了两个四川和尚前往南海的故事。富裕的和尚声称他准备了好几年，要买一艘船沿长江而下。而贫穷的和尚只带了一个水瓶和一个饭碗。一年后，穷和尚从南海归来，富和尚却仍在准备之中。这个故事告诉我们，行动胜于空谈。学习编程亦是如此，与其踟蹰不前，不如立即行动，在实践中不断摸索和学习。\n关于本书\n如果几年前，有人问我：“出版一本书”是不是你人生的梦想之一？我会不假思索地回答他：“这是我来生的梦想。”\n如今，我竟然写了一本书，我认为这得益于以下几个因素：首先，我活跃于网络（现在又有谁不是活跃在网络上呢？），自2016年起便开始录制名为“软件那些事儿”的podcast，至今已录制了400多期节目。此外，我还经常录制编程视频并上传至Bilibili等视频网站。\n其次，我拥有多年的软件开发经验，职业生涯始于Sun公司——正是这家公司创造了Java。尽管我已经离开老东家多年，但心中仍存留着一份特殊的情感。这份情感也延伸至Java，我对这门编程语言抱有许多好感。也正是因为这份情感，让我录第一期podcast的时候，就选择介绍Java语言的历史。现在写一本编程书，我首先想到的也是Java语言。\n最后，也是我认为最重要的一点，我意识到，曾经在编程中所经历的许多纠结与折磨，本是可以避免的。从年轻时在NetBeans项目组摸爬滚打，边工作边学习，却苦于无法完全掌握NetBeans的运作原理的职场新手，到如今成长为能够较为镇定地面对大型项目的架构师，这个过程中，我遇到了无数挑战和困难，有些坑如果当时有人指点或许能够更早地爬出来。如今已是 2021 年，我发现仍有许多新人像当年的我一样，在同样的坑中踽踽独行。我希望通过本书，能够帮助他们尽快摆脱困境。\n此外，由于种种历史原因，Java 的许多先进语言特性和开发模式在国内尚未得到广泛应用。我期望通过本书，倡导采用先进的语言特性，提升程序员的工作效率，使他们能够早日完成工作，提前下班。\n要感谢的人\n本书还邀请了众多我的电台听众担任早期读者，他们提供了宝贵的意见和建议。在此，我谨按反馈顺序向以下听众兼早期读者致以诚挚的谢意：\n张敬畏、吉人、任占东、李振中、毕朋飞、张洁、胡海彦、郝金、王义祥、王恒、黄建晴、弥国伟、黄寒毅、戴峰、代亮、杨兆军、刘杰、唐青平、吴剑钢、王晨、常黎明、王卜锐、严济愈、范宗耀、刘强、陈少川、王之康、付志远、付小辉、邓俊德、赵庶剑、吴昱锡、金希朴、刘天尧、陈尧龙、刘凡恺、徐亚南、彭海璐、王琦、张训、李庆权、贾爱国、车恒彬、陈喆、刘冕、夏明飞、王超、乔鑫、杨碧军、李维洲、苏三、袁宏、徐玉峰、刘卫、周信、孙国庆、黄鑫源、王晋渤、黄国瑞、欧阳宁。\n还有一些朋友不愿透露真实姓名，仅提供了网络 ID：傻牛、大成、浮游、素颜、touchmii、Coding L、推头的拓海、一贯可乐、腾、YuVenhol、wym、菜得抠脚、99、老法师、红薯、雯雯、城哥、丫头、葫芦娃、王女士，船哥、机器学习、秀儿、队长、黄盛、伴娘、Hmtsai、AUGUST、Andy、龙小龙、天涯明月刀、橙子和西瓜、TheWQ、Abel、肥仔强、alibos、NULL、hwf1324、阿强、Tr。\n你们的真知灼见令本书增色不少，在此深表感谢！\n\n\n再次对这些早期读者表示感谢，对没法把名字印在纸上再次表示抱歉。",
    "crumbs": [
      "Java编程",
      "前言"
    ]
  },
  {
    "objectID": "intro1.html",
    "href": "intro1.html",
    "title": "为什么你读不完一本书？",
    "section": "",
    "text": "这不怪你，因为任何知识，都有前置条件。所谓的前置条件，就是为了读懂第1章的概念，你需要读到第9章才会恍然大悟。\n你可能会问，为什么不先写第9章呢？原因是相同的，如果你要读懂第9章的那个概念，要用到第4章里的概念。\n越复杂越系统的专业或者技术书籍越是如此，从入门到精通是理想的状态。\n且不说如何入门，其实，门在什么地方，都不一定能说得清楚。因为专业的知识，到处都是门，你只要从某个地方进入即可，只要深入研究这扇门，一定能将你传送到某个地方，最终会让你豁然开朗。\n举个例子，无论你在大学里学哪个专业，这个专业的知识都被分解成了一门门的课程，这些课程之间互相联系，又分别独立。以计算机科学为例，《计算机组成原理》、《数据结构》、《Java编程》、《网络与通信》、《操作系统原理》……这些课程之间绝对不是独立的，之间有千丝万缕的联系。\n知识是网状的结构，而不是线性的。我们学的每一门知识，都像是一个迷宫。每个节点代表一个知识点，知识点越多，迷宫就越复杂。\n下图是计算机网络知识的联系图，如果你要入门，那么，哪里才是真正的门？\n\n\n\n计算机知识图谱\n\n\n很难说清楚应该从哪个门进入，我们唯一能做的就是无论从哪个门进入，都要在这个迷宫一样的网络图里探索。网络图的特点是，每个节点都不是孤立的，你总可以从一个节点到另一个节点。\n很多人读不完一本技术书籍的原因是：看到不懂的就放弃了。如何解决这个问题呢？也很简单：碰到不懂的不要放弃，而是先放一放，略过这个节点，到下一个节点。知识点不同于爱情，走过路过不要错过。知识点是只要你走过路过，就不会错过，总有那么一个时刻，你会突然间想到那个你当时不懂的点，然后豁然开朗。\n因此，读书一定要养成的一个习惯是：反复阅读教材+做题。\n反复阅读教材可能是最好的自学方法。以我为例吧，我读的高中是我们那个市最差的高中，学校坐落于农村，那个高中只招，也只能招周围农村的学生。别说城里的孩子了，就算农村里有点见识的家长，也不忍心孩子上那个高中。升学率有多低呢？每年可能招700个学生，能考上本科的人数，一般在40-50人左右。对，你没看错，不是400-500人，是40-50人，我高考的那年，好像是39人。我母校的命运也极为悲惨，由于名声在外，只要去读我那所高中，约等于高考失败，越来越多的学生和家长不再报考这所高中，生源就越来越差，最后实在是招不到学生了，就解散了，老师合并到了另一个学校。\n我在这所高中里，考上了重点本科。给了我很大的信心，后来考研究生就不在话下了。虽然日后证明，光会考试的农村做题家其实没啥用（多么痛的领悟！），但是，我的法宝就是反复阅读教材，随机的刷题。\n\n\n\n\n\n\n反复阅读、随机刷题有用么？\n\n\n\n我觉得是有用的。有一本很出名的认知学的书叫《make it stick》，作者是Peter C Brown，我读这本书的时候，有一种似曾相识的感觉，这不就是我从高中以来一直使用的方法么？\n想要掌握知识，就要反复阅读加做题，如果只是重复的阅读，效果并不好。而是要不停的反问自己，情景模拟，使大脑重建立记忆。这一点，在编程中的体验，我认为是读书，写代码，调试。\n调试的时候，就是长脑子的时候。\n\n\n很多人读不完一本技术书籍的原因是因为太难了，但是太难了的原因是没有读完。实际上，如果能继续囫囵吞枣的读下去，再回来看前面，就能理解一些了。也就是说，书不是因为难才读不完，而是因为没读完才显得难。\n我曾经给孩子报过美术课，因为家长总是觉得自己的孩子与众不同，万一我家孩子是个美术天才呢？学一段时间以后，才知道原来也是普通人，这样就安心了。孩子学了多少我不知道，但是我觉得那个叫韦唯的美术老师——之所以我能记住他的名字，是因为他的名字跟一个歌星一样——给我说的一句话，让我受用终生。我说，你看我家孩子画的，可真难看。这个老师说，画画都是这样，画到一半的时候，谁的画都不好看，只有完成了，画才好看。\n我觉得这句话非常正确，软件也是如此，做软件，做到一半的时候，到处是bug，运行起来颤颤悠悠的，但是慢慢的就修复了。很可惜的是，我们很难看到只画了一小部分的画，也不太容易见到bug到处都是的半成品。\n读书也是如此，读到一半的时候，最难了，前面的搞不懂，后面的感觉更搞不懂。于是，大部分人读书就是读个前言，读个开头，就认为自己不是学这个的料。或者有些人一定要把所有的都搞懂，才肯继续下去，这样的结果要么是反复地困在第一第二第三章，要么彻底放弃了。\n书，看不懂也要看完，反复的看，读书百遍，其义自见。\n还有一点，你不用了解编程的所有知识，只需要了解你需要的那些就够了。就像你在一座城市里住了那么久，你知道的可能只是你周边的那一部分，至于其它地方，不知道也无所谓。如果要去，GPS导航一下，也就到了。比如要做一个2D游戏，你暂时不用管什么Java网络编程，即使Java网络编程非常重要，但是，目前真用不上，你就先不用操心了。等到你熟悉了Java 2D游戏编程，会发现，原来Java网络编程也没那么难，你已经会了90%，甚至更多。\n这时候，就需要信心与耐心了。有些人有信心，但是总是三分钟热度，什么事情都想马上出成果，恨不能今天看了Java的编程书，明天做一个Minecraft游戏，卖给微软。还有一些人有耐心，但是没信心。不管你认为你能行还是不能行，你都是对的。如果你打心底就认为这玩意学不懂，太难了，那么，肯定是学不会的。\n一不要急于求成，二不要妄自菲薄。静下心来，全神贯注的投入200-300个小时，一定能搞清楚的。想一下，每天投入3-4个小时，2个月就可以了。只要学会了一门编程语言，再学其它的，都会简单太多了。",
    "crumbs": [
      "Java编程",
      "你为什么读不完一本书？"
    ]
  },
  {
    "objectID": "intro0.html#只要加足够的定语就一定能成为最好的",
    "href": "intro0.html#只要加足够的定语就一定能成为最好的",
    "title": "前言",
    "section": "1.1 只要加足够的定语，就一定能成为最好的。",
    "text": "1.1 只要加足够的定语，就一定能成为最好的。\n我说，我想成为做编程教学最好的电台主播，肯定有人不相信，那么，我再加几个定语吧：我想成为做Java编程教学最好的山东籍离异电台男主播……\n如果一个人，从来没有属于过你，那就无所谓失去。 —— 绿帽子大学校长\n技术可以随便学，毕竟艺不压身；婚不要随便结，人品一定要好，只做筛选，不做改变。若是遇人不淑，又滥生无辜，基本上，就插翅难飞了。—— 绿帽子大学校长\n在婚姻中，可以要求安全感，也可以要求仪式感，但是，不能要求有新鲜感。—— 绿帽子大学校长",
    "crumbs": [
      "Home",
      "前言"
    ]
  },
  {
    "objectID": "content.html",
    "href": "content.html",
    "title": "目录",
    "section": "",
    "text": "1 第1章 初识Java\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n本章介绍了Java的历史，不是说“历史是一面镜子”么？\n\n\n1.1 JAVA简介\n1.1.1 Java初次登场 \n1.1.2 指导Java发展的两份文档 \n1.1.3 Java面对的问题以及解决方案\n1.2 JAVA语言进化史\n1.3 小朋友，你是不是有很多问号？\n1.3.1 为什么James Gosling被称为终身仁慈独裁者？ \n1.3.2 Java的名字是谁起的？ \n1.3.3 James Gosling如何回答相比于C语言，Java不够自由？ \n1.3.4 Java的现状怎么样？\n1.4 程序员故事\n\n\n\n\n\n\n2 第2章 第一行代码\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n这一章的内容主要是把开发环境配置起来，运行第一个程序，在屏幕上输出两个单词：Hello World。\n\n\n2.1 “传统”JAVA版的Hello World\n2.1.1 用什么工具来输入代码？\n2.1.2 输入的时候需要注意什么？\n2.1.3 如何让源代码跑起来？\n2.1.4 碰到bug怎么办？\n2.2 八仙过海的Java虚拟机\n2.2.1 Sun的虚拟机\n2.2.2 BEA的JRockit\n2.2.3 微软的JVM\n2.2.4 Apache的Harmony\n2.2.5 Google的Dalvik\n2.2.6 我的感慨\n2.3 “脱口秀”之表扬与自我表扬\n2.4 小朋友，你是不是有很多问号？\n2.4.1 bytecode是什么？\n2.4.2 javac是编译器么？\n2.4.3 Java虚拟机只能运行Java语言么？\n2.5 “未来版”的Hello World\n2.5 《万物皆零一》\n\n\n\n\n\n\n3 第3章 面向对象编程\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n这一章讲了面向对象编程的历史，并考证了面向对象编程这几大知识点的由来以及用途。\n\n\n3.1 第一门面向对象编程语言——Simula\n3.1 面向对象发明者的故事\n3.2 Simula的研究成果\n3.3 推广Simula\n3.2 Java中的一切皆对象\n3.2.1 什么是对象\n3.2.2 对象怎么工作\n3.3 面向对象为什么这么难？\n3.3.1 名词搅拌器\n3.3.2 滥用隐喻\n3.3.3 过度宣传\n3.4 面向对象可以很简单\n3.4.1 FIFA足球游戏\n3.4.2 对球员进行抽象\n3.4.3 继承\n3.5 虚构的访谈\n3.6 《万物皆零一》\n\n\n\n\n\n\n4 第4章 变量\n\n\n\n\n\n\n\n\n\n\n\n\n变量是构建程序最基本的单位，本章从变量的历史讲起，涵盖了变量命名、变量类型、变量作用域等内容。\n\n\n\n4.1 变量的历史\n4.2 变量的命名\n4.3 变量的数据类型\n4.3.1 基本数据类型\n    4.3.1.1 整数类型\n    4.3.1.2 浮点数类型\n      《考据癖：计算机处理小数的历史》\n    4.3.1.3 字符类型\n      《考据癖：计算机处理字符的历史》\n    4.3.1.4 布尔类型\n    4.3.1.5 类型转换\n4.3.2 引用数据类型\n4.4 变量的作用域\n4.4.1 Java变量的作用域\n4.4.2 作用域的历史\n4.4.3 虚构的故事：动态作用域与静态作用域\n\n\n\n\n\n\n5 第5章 操作符\n\n\n\n\n\n\n\n\n\n\n\n\n小学时候就学了算数操作符与赋值操作符，可能逻辑操作符有一点难度，至于自增、自减那些，一语也就点破了，总之，本章实在是没难度。\n\n\n\n5.1 算数操作符\n5.2 赋值操作符\n5.3 关系操作符\n5.4 逻辑操作符\n5.4.1 逻辑与（AND）\n5.4.2 逻辑或（OR）\n5.4.3 逻辑非（NOT）\n5.5 自增、自减操作符\n5.6 位操作符\n5.7 三元操作符\n5.8 操作符的优先级\n\n\n\n\n\n\n6 第6章 结构化编程\n\n\n\n\n\n\n\n\n\n\n\n\n人类开发软件之后，遇到了第一次软件危机，经过众多科学家的折腾，终于捯饬出来了结构化编程……简单来说，所有的编程都可以用顺序、选择与循环来搞定，我给出了他们当初的论文来证明这一点。这一章算是非常重要的。\n\n\n\n6.1 结构化编程的由来\n6.2 顺序结构\n6.2.1 前后顺序无关的代码\n6.2.2 有明确顺序的代码\n6.3 选择结构\n6.3.1 if语句\n6.3.2 switch语句\n6.4 循环结构\n6.4.1 do-while循环\n6.4.2 while循环\n6.4.3 for循环\n6.4.4 增强的for循环\n6.4.5 break与continue\n6.4.6 标签\n\n\n\n\n\n7 第7章 方法\n\n\n\n\n\n\n\n\n\n\n\n\n英国科学家大卫·惠勒（David Wheeler）发明了方法，从此所有的编程语言都开始支持方法。可以说，没有方法，无法进行编程。同时，递归是一种比较特殊的方法，如果运用恰当，可以大大简化编程。\n\n\n\n7.1 方法的概述\n7.2 方法的声明与调用\n7.3 方法的参数\n7.3.1 命名参数\n7.3.2 可变参数\n7.3.3 形参与实参\n7.4 方法的返回值\n7.5 递归\n7.5.1 递归步骤与终止条件\n7.5.2 递归实现科赫雪花\n\n\n\n\n\n8 第8章 数组\n\n\n\n\n\n\nWarning\n\n\n\n\n\n\n\n\n\n数组是一种古老的数据结构，太过于“原始”，我觉得应该使用更先进的ArrayList等数据结构。但是，数组仍有大量的人在使用，所以，我们也要学习。\n\n\n\n8.1 数组概述\n8.2 数组的声明\n8.3 数组的初始化\n8.3.1 静态初始化\n8.3.2 动态初始化\n8.4 多维数组\n8.4.1 二维数组\n8.4.2 三维数组\n8.5 用数组实现本福特定律\n\n\n\n\n9 第9章 类、对象与封装\n\n\n\n\n\n\n\n\n\n\n\n\n如何把功能相关的代码组织到一起呢？答案是用“类”。\n\n\n\n9.1 类、对象与封装\n9.2 属性与方法\n9.2.1 访问修饰符\n9.2.2 getter和setter方法\n9.2.3 构造函数\n9.2.4 如何使用this关键字？\n9.3 静态成员\n\n\n\n\n\n10 第10章 包\n\n\n\n\n\n\n\n\n\n\n\n\n如何把功能相关的类组织到一起呢？答案是用“包”。\n\n\n\n10.1 包的简介\n10.2 包的语法与用法\n10.2.1 如何声明包\n10.2.2 如何导入包\n10.2.3 如何使用包中的成员\n10.3 使用包的最佳实践\n10.3.1 如何命名包？\n10.3.2 如何以包为结构组织项目代码\n\n\n\n\n\n11 第11章 继承\n\n\n\n\n\n\n\n\n\n\n\n\n权力可以继承，财富可以继承，代码就不可以继承么？当然能！\n继承最重要的功能是为了代码重用，减少代码的重复。官/富二代最重要的功能也是继承富一代的权与钱，减少从零奋斗的过程。\n\n\n\n11.1 什么是继承\n11.2 类实例的继承机制\n11.2.1 子类可以继承父类的属性么？\n11.2.2 子类可以继承父类的方法么？\n10.2.3 如何使用super关键字？\n11.3 静态成员的继承机制\n11.4 不可被继承的类和方法\n11.4.1 final用于修饰类是用来阻止类被继承\n11.4.2 final用于修饰方法是阻止方法被覆盖\n11.5 多重继承的问题\n\n\n\n\n\n12 第12章 抽象类\n\n\n\n\n\n\n\n\n\n\n\n\n在《公孙龙子·白马论》中提出了“白马非马”的诡辩，如果第二个马是抽象类的话，那么“白马”就是“马”。“公孙龙”认为“马”不能实例化，但是“白马”可以实例化。\n我认为战国时期的公孙龙所持有的“每个事物只能是它自己，事物间不存在联系”的观点是错误的，至少在面向对象中是如此。\n不能实例化的“马”，在面向对象编程中叫“抽象类”。\n\n\n\n12.1 抽象类概述\n12.2 抽象类的实现\n\n\n\n\n\n13 第13章 接口\n\n\n\n\n\n\n\n\n\n\n\n\n在11章里讲过，Java不能多重继承，爸当官，妈当官，难道孩子不能同时继承两者的权力与财富么？在现实中，肯定能！（不信你看哪个公子，哪条鲶鱼，都是多重继承的……）\n但是在Java中却不能，Java不支持多重继承，如果你需要多重继承怎么办？用接口。\nhttp://www.gotw.ca/publications/c_family_interview.htm 在这篇访谈中，C++的作者与Java的作者，都谈到了编程语言的设计，其实Java的作者对接口与类的设计也不满意。\n\n\n\n13.1 接口的历史\n13.2 接口的定义与实现\n13.3 接口与抽象类\n13.4 接口引入DEFAULT方法\n13.5 接口中引入静态方法\n13.6 接口的继承与多重继承\n13.6.1 接口的作用\n13.6.2 接口与抽象的区别\n\n\n\n\n\n14 第14章 多态\n\n\n\n\n\n\n\n\n\n\n\n\n什么动物婴儿时四条腿，成年后两条腿，老年时三条腿？答案是：人。\n当我们调用走路的时候，同样的人，但是有不同的走路形态，小时候爬，长大后两条腿，老年后拄着一根拐杖。\n这就是多态，用统一的方式（走路），却实现了不同的形态（爬，走，拄拐）。\n本章介绍了如何用不同的方法实现多态。\n\n\n\n14.1 用继承来实现多态\n14.1.1 方法重写（Override）为多态提供基础\n14.1.2 向上转型（Upcasting）为多态提供统一调用方式\n14.2 用接口来实现多态\n14.3 用继承与用接口实现多态有什么不同？\n14.4 用泛型来实现多态\n\n\n\n\n\n15 第15章 集合\n\n\n\n\n\n\n\n\n\n\n\n\n第8章的时候，我“黑”了一下数组，数组作为一种数据结构，实在是太原始了。\n那用什么方法来代替数组呢？就是本章讲的集合。\n集合比数组好用太多了，不一个时代的产品。\n\n\n\n15.1 集合的基本概念\n15.1.1 什么是集合\n15.1.2 集合与数组的区别\n15.2 Java集合框架的架构体系\n15.3 集合的核心接口与实现类\n15.3.1 Iterable接口\n15.3.2 Collection接口\n15.3.3 List接口以及实现类\n15.3.4 Set接口以及实现类\n15.3.5 Map接口以及实现类\n\n\n\n\n\n16 第16章 异常处理\n\n\n\n\n\n\n\n\n\n\n\n\n嫦娥应悔偷灵药，碧海青天夜夜心。\n嫦娥犯的错，只能无限的懊悔，毕竟没有后悔药卖。但是Java中，为异常处理设置了非常多的防御措施，确保嫦娥偷不到灵药，防患于未然 :)\n\n\n\n16.1 异常的基础概念\n16.1.1 什么是异常\n16.1.2 异常的类型和层次结构\n16.1.3 Error和Exception的区别\n16.2 异常捕获处理\n16.2.1 throws语句\n16.2.2 try-catch-finally语句\n16.3 Java内置的常见异常类型\n16.3.1 非受检异常（Unchecked Exception）\n16.3.2 受检异常（Checked Exceptions）\n16.3.3 错误（Error）\n16.4 自定义异常\n16.5 异常链\n16.6 异常与资源管理\n\n\n\n\n\n17 第17章 函数式编程\n\n\n\n\n\n\n\n\n\n\n\n\n绝大部分Java编程书上，都不讲泛型，一是太难，二是觉得没什么用。但是，看看下面的语言：\nJava之前不支持泛型，Java 5之后增加了泛型。\nC#之前不支持泛型，C# 2.0之后增加了泛型。\nGo语言之前不支持泛型，G为1.18之后增加了泛型。\n难肯定是难的，有用肯定是有用的，花点时间是值得的。\n泛型解决的问题与继承、多态解决的问题是一脉相承的：代码复用。比如容器中可以存整数，也可存小数，还可以存小猫小狗这样的对象……如果逻辑一样，一点小改动就要重新调整代码，自己也受不了……\n现实中也是如此，油罐车可以拉煤油，可以拉汽油，甚至可以拉食用油……这当然可能会出现各种安全问题，所以需要很多的技术来确保安全。\n\n\n\n17.1 泛型的概念与作用\n17.1.1 Java泛型的历史\n17.1.2 泛型的用途与语法\n17.2 如何定义泛型类？\n17.3 如何定义泛型接口？\n17.4 如何定义泛型方法？\n17.4.1 泛型方法和多态的区别\n17.4.2 泛型方法与泛型类、泛型接口的区别\n17.5 类型通配符的概念与使用场景\n17.5.1 无界通配符（?）的概念与使用场景\n17.5.2 上界通配符（\\&lt;? extends XXX\\&gt;）的概念与使用场景\n17.5.3 下界通配符（\\&lt;? super XXX\\&gt;）的概念与使用场景\n17.5.4 通配符的PECS(Producer Extends,Consumer Super)原则\n17.6 泛型的继承与子类型规则\n17.6.1 泛型的不变性规则及其影响\n17.6.2 通配符的协变规则与逆变规则\n17.7 泛型中的类型擦除\n17.7.1 什么是类型擦除\n17.7.2 JVM在编译时如何处理泛型\n17.7.3 类型擦除对编程的影响\n17.7.4 泛型对数组的影响\n\n\n\n\n\n18 第18章 函数式编程\n\n\n\n\n\n\n\n\n\n\n\n\n离婚的原因是什么？千千万万，但是最重要的一个是：心变了。\nbug的原因是什么？千千万万，但是最重要的一个是：状态变了。\n什么叫状态变了呢？64核的CPU中，有1个核修改了全局变量，但其它63个核不知道；有个文件被修改了，但其它进程不知道…… 状态改变，是bug的高发原因。\n如何让离婚率变为0？方法是减少结婚，有感情的就同居得了。\n如何让bug减少？方法是减少命令式编程，增加函数式编程。\n于是，随着CPU核心的增多、分布式、协同式程序的增多，不改变程序状态的函数式编程“死灰复燃”了……\n本章从Lisp历史谈起，让大家清晰的了解什么叫函数式编程，为何Java的函数式编程不如Lisp那么优雅……\n\n\n\n18.1 第一门函数式编程语言：LISP语言\n18.1.1 Lisp简介\n18.1.2 Racket以及Racket的语法\n18.2 Lambda表达式\n18.2.1 什么是Lambda表达式\n18.2.2 无参数的Lambda表达式\n18.2.3 有一个参数的Lambda表达式\n18.2.4 有两个参数的Lambda表达式\n18.2.5 如何将Lambda表达式赋值给变量？\n18.3 函数式接口\n18.3.1 为什么需要函数式接口?\n18.3.2 函数式接口的种类有多少?\n18.3.3 函数式接口为何只能有一个抽象方法？\n18.3.4 方法引用\n18.3.5 如何自定义函数式接口?\n18.4 Stream API\n18.4.1 什么是Stream\n18.4.2 创建Stream的各种方式\n18.4.3 Stream操作的分类\n18.4.4 常见的中间操作\n18.4.5 常见的终端操作\n\n\n\n\n\n19 第19章 枚举类型\n\n\n\n\n\n\n\n\n\n\n\n\n在Java中，枚举已经强大到什么地步了呢？几乎所有类能做的事情，枚举都能做。枚举是一种特殊的类。\n枚举不止是简单的常量的集合，还可以拥有属性、方法和构造函数。还支持接口和实现。\n简单来说，枚举是受限的类。\n\n\n\n19.1 枚举概述\n19.1.1 什么是枚举\n19.1.2 枚举和常量的区别\n19.2 定义枚举\n19.3 枚举的高级特性\n19.3.1 枚举类型不能继承，但是可以实现接口\n19.3.2 枚举无法被实例化\n19.3.3 枚举常量实例最好设置为final\n19.3.4 不能依赖于枚举常量的序数\n19.3.5 values()和valueOf()方法\n19.3.6 EnumSet和EnumMap\n\n\n\n\n\n20 第20章 注解\n\n\n\n\n\n\n\n\n\n\n\n\n注解是Java 5之后引入的。\n对司机而言，开车的时候，最重要的信息是路上的指示牌。比如看到“前方有急转弯”，你就会注意一点。\n同样，注解类似于这些路牌，当看到@Override的时候，编译器会去查一下父类中是否有这个方法，当看到@Deprecated的时候，会提示这个方法已经过时了……\n注解的本质是提供额外的元数据和指示，帮助编译器、工具和开发者更好地理解和处理代码。\n\n\n\n20.1 什么是注解\n20.2 在代码中使用Java预定义的注解\n20.2.1 注解与注释的区别\n20.2.2 使用Java预定义的注解\n20.3 在代码中使用自定义的注解\n20.3.1 定义注解\n20.3.2 使用注解\n20.3.3 解析注解\n\n\n\n\n\n21 第21章 反射\n\n\n\n\n\n\n\n\n\n\n\n\n据说，违反法律最刺激，要是违反了法律还不被制裁，就更是刺激了。比如古人有云：“妻不如…”，这句话你自己去搜搜吧。\n前面我们讲类的作用，又是封装，又是隐藏。然后突然来一个机制，啥封装，啥隐藏？直接给你显微镜下看的明明白白的……是不是很刺激？\n反射就是这样的，使用反射，咱们可以正在光明的走后门，所有的类定义的条条框框，都可以不用遵守。让你觉得像个特权阶级。\n\n\n\n21.1 反射的历史与发展\n21.1.1 起初，反射仅仅是为了跨平台\n21.1.2 后来，反射的发展就“失控”了\n21.2 获取Class对象\n22.2.1 Class对象是Java反射机制的基础\n22.2.2 获取Class对象的三种方式\n21.3 基础的反射API\n21.3.1 构造类操作\n21.3.2 属性类操作 \n21.3.3 方法类操作\n21.4 MethodHandler和VarHandle\n21.5 反射的局限\n21.5.1 性能开销问题\n21.5.2 破坏封装性\n21.5.3 反射代码往往难以维护\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n这本书写了21章，而且肯定还有很多内容没有覆盖到，如果我说一些漂亮话，什么“书山有路勒为径，学海无涯苦作舟”，让大家再多学点什么的，一般人实际上内心是比较崩溃的。\n那学到什么时候是个头啊？！\n实际上，你根本不需要学这么多。我之所以写这么多，是因为这是“写书”，其目的是“尽量覆盖”，而现实中做项目，其目的是“尽快做完下班”。\n如果你继续读我剩下的三本书，你会发现，每本书都只是用到这本书里“部分内容”，比如做游戏，你就用不到反射，也用不到函数编程，因此会不会这些稀奇古怪的东西，对开发游戏完全没影响。",
    "crumbs": [
      "Java编程",
      "点击查看完整目录"
    ]
  },
  {
    "objectID": "content.html#java简介",
    "href": "content.html#java简介",
    "title": "目录",
    "section": "1.1 JAVA简介",
    "text": "1.1 JAVA简介\n\n1.1.1 Java初次登场\n\n\n1.1.2 指导Java发展的两份文档\n\n\n1.1.3 Java面对的问题以及解决方案",
    "crumbs": [
      "Home",
      "点击查看-->详细目录<--"
    ]
  },
  {
    "objectID": "content.html#java语言的优势",
    "href": "content.html#java语言的优势",
    "title": "目录",
    "section": "",
    "text": "第一行代码 17 2.1 “传统”JAVA版的HELLO WORLD 17 2.1.1 编辑源代码 17 2.1.2 编译和运行 18 2.1.3 回顾写程序的流程 20 2.2 解析代码 21 2.2.1 注释 22 2.2.2 声明类 23 2.2.3 main方法 24 2.2.4 语句 25 2.3 调试程序 25 2.3.1 调试程序的步骤与方法 27 2.3.2 选择一个好用的开发环境 27 2.4 JAVA虚拟机简史 28 2.4.1 Oracle的HotSpot虚拟机 28 2.4.2 IBM OpenJ9虚拟机 29 2.4.3 BEA的JRockit 29 2.5 脱口秀：程序员，编译器，虚拟机 30 2.6 “未来”JAVA版的HELLO WORLD 31 2.7 附录 32 2.8 总结 32\n面向对象 35 3.1 第一门面向对象编程语言 35 3.1.1 面向对象的发源项目 35 3.1.2 Simula核心概念 36 3.1.3 Simula的普及 39 3.2 JAVA：一切皆对象 40 3.2.1 什么是“对象” 40 3.2.2 “对象”有什么用？ 42 3.3 面向对象编程为什么这么难 43 3.3.1 名词搅拌器 43 3.3.2 滥用隐喻 44 3.3.3 过度宣传 45 3.4 面向对象编程可以很简单 46 3.4.1 FIFA足球游戏 47 3.4.2 设计孤立的类很简单 48 3.4.3 类之间的关系才是难点 51 3.5 脱口秀：面向对象的优点 59 3.6 总结 67\n变量 69 4.1 变量的历史 70 4.2 变量名 70 4.3 变量的数据类型 72 4.3.1 基本数据类型的变量 74 4.3.2 引用数据类型的变量 84 4.4 变量作用域 85 4.4.1 Java中变量的作用域 85 4.4.2 作用域的历史 86 4.4.3 故事：动态作用域和静态作用域 88 4.5 本章附录 91 4.5.1 计算机中小数处理的历史 91 4.5.2 计算机中字符处理的历史 95 4.6 总结 99\n操作符 102 5.1 算术操作符 104 5.2 赋值操作符 105 5.3 关系操作符 107 5.4 逻辑操作符 110 5.4.1 逻辑“与”（AND） 110 5.4.2 逻辑“或”（OR） 111 5.4.3 逻辑“非”（NOT） 113 5.5 自增、自减操作符 113 5.6 位操作符 114 5.7 三元操作符 116 5.8 操作符的优先级 117 5.9 本章附录 118 5.10 总结 121\n结构化编程 122 6.1 结构化编程的由来 123 6.2 顺序结构 124 6.2.1 前后顺序无关的代码 125 6.2.2 有明确顺序的代码 126 6.3 选择结构 127 6.3.1 if语句 128 6.3.2 switch语句 131 6.4 循环结构 138 6.4.1 do-while循环 139 6.4.2 while循环 140 6.4.3 for循环 142 6.4.4 增强的for循环 143 6.4.5 break和continue 145 6.4.6 标签 147 6.4.7 小结 148 6.5 本章附录 149 6.6 总结 151\n方法 153 7.1 方法的概述 153 7.2 方法的声明与调用 155 7.3 方法的参数 156 7.3.1 命名参数 158 7.3.2 可变参数 160 7.3.3 形参与实参 162 7.4 方法的返回值 162 7.5 递归 168 7.5.1 递归步骤与终止条件 168 7.5.2 递归实现科赫雪花 169 7.6 总结 173\n数组 174 8.1 数组概述 174 8.2 数组的声明 174 8.3 数组的初始化 175 8.3.1 静态初始化 175 8.3.2 动态初始化 176 8.4 多维数组 178 8.4.1 二维数组 178 8.4.2 三维数组 180 8.5 用数组实现本福特定律 181 8.6 总结 183\n类、对象和封装 185 9.1 类与对象 186 9.2 属性与方法 186 9.2.1 访问修饰符 188 9.2.2 getter 和 setter方法 189 9.2.3 构造函数 193 9.2.4 如何使用this关键字 196 9.3 静态成员 198 9.4 总结 200\n包 202 10.1 包的简介 202 10.2 语法和用法 202 10.2.1 如何声明package 202 10.2.2 如何导入包 203 10.2.3 如何使用package中的成员 205 10.3 最佳实践 206 10.3.1 如何命名包 206 10.3.2 以包为结构组织项目代码 206 10.4 总结 207\n继承 209 11.1 继承的语法 209 11.2 类实例的继承机制 210 11.2.1 子类可以继承父类的属性么？ 210 11.2.2 子类可以继承父类的方法么？ 212 11.2.3 子类可以继承父类的构造函数么？ 214 11.2.4 如何使用super关键字？ 215 11.3 静态成员的继承机制 218 11.4 不可被继承的类和方法 220 11.4.1 final用于修饰类是阻止类继承 220 11.4.2 final用于修饰方法是阻止方法被覆盖 220 11.5 总结 222\n抽象类 224 12.1 抽象类概述 224 12.2 抽象类的实现 225 12.3 总结 229\n接口 230 13.1 接口小史 230 13.2 接口的定义与实现 231 13.3 接口与抽象类 233 13.3.1 接口的作用 233 13.3.2 接口与抽象类的区别 233 13.4 接口引入DEFAULT方法 238 13.5 接口中引入静态方法 240 13.6 接口的继承与多重继承 243 13.7 总结 246\n多态 248 14.1 用继承来实现多态 248 14.1.1 方法（Override）重写为多态提供基础 248 14.1.2 向上转型（Upcasting）为多态提供统一调用方式 250 14.2 用接口（INTERFACE）实现多态 253 14.3 用继承跟用接口实现多态有什么不同？ 256 14.4 用泛型实现多态 257 14.5 总结 257\n集合 260 15.1 集合的基本概念 262 15.1.1 什么是集合 262 15.1.2 集合与数组的区别 263 15.2 JAVA集合框架的架构体系 264 15.3 核心接口与实现类 266 15.3.1 Iterable接口 266 15.3.2 Collection接口 266 15.3.3 List接口以及实现类 267 15.3.4 Set接口以及实现类 269 15.3.5 Map接口以及实现类 272 15.4 本章附录 275 15.5 总结 277\n错误处理 279 16.1 异常基础概念 279 16.1.1 什么是异常 279 16.1.2 异常的类型和层次结构 279 16.1.3 Error和Exception的区别 281 16.2 异常捕获处理 282 16.2.1 throws语句 282 16.2.2 try-catch-finally语句 283 16.3 JAVA内置的常见异常类型 286 16.3.1 非受检异常（Unchecked Exception） 286 16.3.2 受检异常（Checked Exceptions） 287 16.3.3 错误（Error）： 287 16.4 自定义异常 288 16.5 异常链 290 16.6 异常与资源管理 292 16.7 总结 294\n泛型 296 17.1 泛型的概念与作用 296 17.1.1 Java泛型的历史 297 17.1.2 泛型的用途与语法 298 17.2 定义泛型类 300 17.3 定义泛型接口 302 17.4 定义泛型方法 304 17.4.1 泛型方法和多态 306 17.4.2 泛型方法与泛型类、泛型接口的区别 306 17.5 类型通配符的概念与使用场景 307 17.5.1 无界通配符 ( ? ) 307 17.5.2 上界通配符 （ &lt;? extends XXX&gt; ） 308 17.5.3 下界通配符（ &lt;? super XXX&gt; ） 309 17.5.4 通配符的PECS原则(Producer Extends,Consumer Super) 310 17.6 泛型的继承与子类型规则 310 17.6.1 泛型的不变性规则及其影响 310 17.6.2 通配符的协变规则与逆变规则 313 17.7 泛型中的类型擦除 314 17.7.1 什么是类型擦除 314 17.7.2 JVM在编译时如何处理泛型 315 17.7.3 类型擦除对编程的影响 315 17.7.4 泛型与数组 316 17.8 总结 316\n函数式编程 318 18.1 第一门函数式编程语言：LISP语言 318 18.1.1 Lisp简介 318 18.1.2 Racket以及Racket的语法 319 18.2 LAMBDA表达式 321 18.2.1 什么是Lambda表达式 321 18.2.2 无参数的Lambda表达式 321 18.2.3 有一个参数的Lambda表达式 323 18.2.4 有两个参数的Lambda表达式 323 18.2.5 将Lambda表达式赋值给变量 324 18.3 函数式接口 325 18.3.1 为什么需要函数式接口 325 18.3.2 函数式接口的种类有多少 325 18.3.3 函数式接口为何只能有一个抽象方法？ 326 18.3.4 方法引用 327 18.3.5 自定义函数式接口 327 18.4 STREAM API 329 18.4.1 什么是Stream 329 18.4.2 创建Stream的各种方式 330 18.4.3 Stream操作的分类 331 18.4.4 常见的中间操作 334 18.4.5 常见的终端操作 338 18.5 总结 344\n枚举类型 346 19.1 枚举概述 346 19.1.1 什么是枚举 346 19.1.2 枚举和常量的区别 347 19.2 定义枚举 347 19.3 枚举的高级特性 350 19.3.1 枚举类型不能继承，但是可以实现接口 350 19.3.2 枚举无法被实例化 351 19.3.3 枚举常量实例最好设置为final 351 19.3.4 不能依赖于枚举常量的序数 351 19.3.5 values()和valueOf()方法 352 19.3.6 EnumSet和EnumMap 352 19.4 总结 355\n注解 357 20.1 什么是注解 357 20.2 在代码中使用JAVA预定义的注解 358 20.2.1 注解与注释的区别 358 20.2.2 使用Java预定义的注解 359 20.3 在代码中使用自定义的注解 361 20.3.1 定义注解 361 20.3.2 使用注解 362 20.3.3 解析注解 362 20.4 总结 363\n反射 365 21.1 反射的历史与发展 366 21.1.1 起初，反射仅仅是为了跨平台 366 21.1.2 后来，反射的发展就出乎意料了 368 21.2 获取CLASS对象 368 21.2.1 示例代码 369 21.2.2 获取Class对象的三种方式 371 21.3 基础的反射API 374 21.3.1 构造类操作 375 21.3.2 属性类操作 377 21.3.3 方法类操作 379 21.4 METHODHANDLE和VARHANDLE 382 21.5 反射的局限 385 21.5.1 性能开销问题 385 21.5.2 破坏封装性 385 21.5.3 反射代码往往难以维护 385 21.6 总结 386",
    "crumbs": [
      "Home",
      "点击查看-->详细目录<--"
    ]
  },
  {
    "objectID": "content.html#程序员故事",
    "href": "content.html#程序员故事",
    "title": "目录",
    "section": "1.4 程序员故事",
    "text": "1.4 程序员故事",
    "crumbs": [
      "Home",
      "点击查看-->详细目录<--"
    ]
  },
  {
    "objectID": "content.html#传统java版的hello-world-17",
    "href": "content.html#传统java版的hello-world-17",
    "title": "目录",
    "section": "1 “传统”JAVA版的HELLO WORLD 17",
    "text": "1 “传统”JAVA版的HELLO WORLD 17\n2.1.1 编辑源代码 17 2.1.2 编译和运行 18 2.1.3 回顾写程序的流程 20 2.2 解析代码 21 2.2.1 注释 22 2.2.2 声明类 23 2.2.3 main方法 24 2.2.4 语句 25 2.3 调试程序 25 2.3.1 调试程序的步骤与方法 27 2.3.2 选择一个好用的开发环境 27 2.4 JAVA虚拟机简史 28 2.4.1 Oracle的HotSpot虚拟机 28 2.4.2 IBM OpenJ9虚拟机 29 2.4.3 BEA的JRockit 29 2.5 脱口秀：程序员，编译器，虚拟机 30 2.6 “未来”JAVA版的HELLO WORLD 31 2.7 附录 32 2.8 总结 32\n\n面向对象 35 3.1 第一门面向对象编程语言 35 3.1.1 面向对象的发源项目 35 3.1.2 Simula核心概念 36 3.1.3 Simula的普及 39 3.2 JAVA：一切皆对象 40 3.2.1 什么是“对象” 40 3.2.2 “对象”有什么用？ 42 3.3 面向对象编程为什么这么难 43 3.3.1 名词搅拌器 43 3.3.2 滥用隐喻 44 3.3.3 过度宣传 45 3.4 面向对象编程可以很简单 46 3.4.1 FIFA足球游戏 47 3.4.2 设计孤立的类很简单 48 3.4.3 类之间的关系才是难点 51 3.5 脱口秀：面向对象的优点 59 3.6 总结 67 4. 变量 69 4.1 变量的历史 70 4.2 变量名 70 4.3 变量的数据类型 72 4.3.1 基本数据类型的变量 74 4.3.2 引用数据类型的变量 84 4.4 变量作用域 85 4.4.1 Java中变量的作用域 85 4.4.2 作用域的历史 86 4.4.3 故事：动态作用域和静态作用域 88 4.5 本章附录 91 4.5.1 计算机中小数处理的历史 91 4.5.2 计算机中字符处理的历史 95 4.6 总结 99 5. 操作符 102 5.1 算术操作符 104 5.2 赋值操作符 105 5.3 关系操作符 107 5.4 逻辑操作符 110 5.4.1 逻辑“与”（AND） 110 5.4.2 逻辑“或”（OR） 111 5.4.3 逻辑“非”（NOT） 113 5.5 自增、自减操作符 113 5.6 位操作符 114 5.7 三元操作符 116 5.8 操作符的优先级 117 5.9 本章附录 118 5.10 总结 121 6. 结构化编程 122 6.1 结构化编程的由来 123 6.2 顺序结构 124 6.2.1 前后顺序无关的代码 125 6.2.2 有明确顺序的代码 126 6.3 选择结构 127 6.3.1 if语句 128 6.3.2 switch语句 131 6.4 循环结构 138 6.4.1 do-while循环 139 6.4.2 while循环 140 6.4.3 for循环 142 6.4.4 增强的for循环 143 6.4.5 break和continue 145 6.4.6 标签 147 6.4.7 小结 148 6.5 本章附录 149 6.6 总结 151 7. 方法 153 7.1 方法的概述 153 7.2 方法的声明与调用 155 7.3 方法的参数 156 7.3.1 命名参数 158 7.3.2 可变参数 160 7.3.3 形参与实参 162 7.4 方法的返回值 162 7.5 递归 168 7.5.1 递归步骤与终止条件 168 7.5.2 递归实现科赫雪花 169 7.6 总结 173 8. 数组 174 8.1 数组概述 174 8.2 数组的声明 174 8.3 数组的初始化 175 8.3.1 静态初始化 175 8.3.2 动态初始化 176 8.4 多维数组 178 8.4.1 二维数组 178 8.4.2 三维数组 180 8.5 用数组实现本福特定律 181 8.6 总结 183 9. 类、对象和封装 185 9.1 类与对象 186 9.2 属性与方法 186 9.2.1 访问修饰符 188 9.2.2 getter 和 setter方法 189 9.2.3 构造函数 193 9.2.4 如何使用this关键字 196 9.3 静态成员 198 9.4 总结 200 10. 包 202 10.1 包的简介 202 10.2 语法和用法 202 10.2.1 如何声明package 202 10.2.2 如何导入包 203 10.2.3 如何使用package中的成员 205 10.3 最佳实践 206 10.3.1 如何命名包 206 10.3.2 以包为结构组织项目代码 206 10.4 总结 207 11. 继承 209 11.1 继承的语法 209 11.2 类实例的继承机制 210 11.2.1 子类可以继承父类的属性么？ 210 11.2.2 子类可以继承父类的方法么？ 212 11.2.3 子类可以继承父类的构造函数么？ 214 11.2.4 如何使用super关键字？ 215 11.3 静态成员的继承机制 218 11.4 不可被继承的类和方法 220 11.4.1 final用于修饰类是阻止类继承 220 11.4.2 final用于修饰方法是阻止方法被覆盖 220 11.5 总结 222 12. 抽象类 224 12.1 抽象类概述 224 12.2 抽象类的实现 225 12.3 总结 229 13. 接口 230 13.1 接口小史 230 13.2 接口的定义与实现 231 13.3 接口与抽象类 233 13.3.1 接口的作用 233 13.3.2 接口与抽象类的区别 233 13.4 接口引入DEFAULT方法 238 13.5 接口中引入静态方法 240 13.6 接口的继承与多重继承 243 13.7 总结 246 14. 多态 248 14.1 用继承来实现多态 248 14.1.1 方法（Override）重写为多态提供基础 248 14.1.2 向上转型（Upcasting）为多态提供统一调用方式 250 14.2 用接口（INTERFACE）实现多态 253 14.3 用继承跟用接口实现多态有什么不同？ 256 14.4 用泛型实现多态 257 14.5 总结 257 15. 集合 260 15.1 集合的基本概念 262 15.1.1 什么是集合 262 15.1.2 集合与数组的区别 263 15.2 JAVA集合框架的架构体系 264 15.3 核心接口与实现类 266 15.3.1 Iterable接口 266 15.3.2 Collection接口 266 15.3.3 List接口以及实现类 267 15.3.4 Set接口以及实现类 269 15.3.5 Map接口以及实现类 272 15.4 本章附录 275 15.5 总结 277 16. 错误处理 279 16.1 异常基础概念 279 16.1.1 什么是异常 279 16.1.2 异常的类型和层次结构 279 16.1.3 Error和Exception的区别 281 16.2 异常捕获处理 282 16.2.1 throws语句 282 16.2.2 try-catch-finally语句 283 16.3 JAVA内置的常见异常类型 286 16.3.1 非受检异常（Unchecked Exception） 286 16.3.2 受检异常（Checked Exceptions） 287 16.3.3 错误（Error）： 287 16.4 自定义异常 288 16.5 异常链 290 16.6 异常与资源管理 292 16.7 总结 294 17. 泛型 296 17.1 泛型的概念与作用 296 17.1.1 Java泛型的历史 297 17.1.2 泛型的用途与语法 298 17.2 定义泛型类 300 17.3 定义泛型接口 302 17.4 定义泛型方法 304 17.4.1 泛型方法和多态 306 17.4.2 泛型方法与泛型类、泛型接口的区别 306 17.5 类型通配符的概念与使用场景 307 17.5.1 无界通配符 ( ? ) 307 17.5.2 上界通配符 （ &lt;? extends XXX&gt; ） 308 17.5.3 下界通配符（ &lt;? super XXX&gt; ） 309 17.5.4 通配符的PECS原则(Producer Extends,Consumer Super) 310 17.6 泛型的继承与子类型规则 310 17.6.1 泛型的不变性规则及其影响 310 17.6.2 通配符的协变规则与逆变规则 313 17.7 泛型中的类型擦除 314 17.7.1 什么是类型擦除 314 17.7.2 JVM在编译时如何处理泛型 315 17.7.3 类型擦除对编程的影响 315 17.7.4 泛型与数组 316 17.8 总结 316 18. 函数式编程 318 18.1 第一门函数式编程语言：LISP语言 318 18.1.1 Lisp简介 318 18.1.2 Racket以及Racket的语法 319 18.2 LAMBDA表达式 321 18.2.1 什么是Lambda表达式 321 18.2.2 无参数的Lambda表达式 321 18.2.3 有一个参数的Lambda表达式 323 18.2.4 有两个参数的Lambda表达式 323 18.2.5 将Lambda表达式赋值给变量 324 18.3 函数式接口 325 18.3.1 为什么需要函数式接口 325 18.3.2 函数式接口的种类有多少 325 18.3.3 函数式接口为何只能有一个抽象方法？ 326 18.3.4 方法引用 327 18.3.5 自定义函数式接口 327 18.4 STREAM API 329 18.4.1 什么是Stream 329 18.4.2 创建Stream的各种方式 330 18.4.3 Stream操作的分类 331 18.4.4 常见的中间操作 334 18.4.5 常见的终端操作 338 18.5 总结 344 19. 枚举类型 346 19.1 枚举概述 346 19.1.1 什么是枚举 346 19.1.2 枚举和常量的区别 347 19.2 定义枚举 347 19.3 枚举的高级特性 350 19.3.1 枚举类型不能继承，但是可以实现接口 350 19.3.2 枚举无法被实例化 351 19.3.3 枚举常量实例最好设置为final 351 19.3.4 不能依赖于枚举常量的序数 351 19.3.5 values()和valueOf()方法 352 19.3.6 EnumSet和EnumMap 352 19.4 总结 355 20. 注解 357 20.1 什么是注解 357 20.2 在代码中使用JAVA预定义的注解 358 20.2.1 注解与注释的区别 358 20.2.2 使用Java预定义的注解 359 20.3 在代码中使用自定义的注解 361 20.3.1 定义注解 361 20.3.2 使用注解 362 20.3.3 解析注解 362 20.4 总结 363 21. 反射 365 21.1 反射的历史与发展 366 21.1.1 起初，反射仅仅是为了跨平台 366 21.1.2 后来，反射的发展就出乎意料了 368 21.2 获取CLASS对象 368 21.2.1 示例代码 369 21.2.2 获取Class对象的三种方式 371 21.3 基础的反射API 374 21.3.1 构造类操作 375 21.3.2 属性类操作 377 21.3.3 方法类操作 379 21.4 METHODHANDLE和VARHANDLE 382 21.5 反射的局限 385 21.5.1 性能开销问题 385 21.5.2 破坏封装性 385 21.5.3 反射代码往往难以维护 385 21.6 总结 386",
    "crumbs": [
      "Home",
      "点击查看-->详细目录<--"
    ]
  },
  {
    "objectID": "content.html#java语言进化史",
    "href": "content.html#java语言进化史",
    "title": "目录",
    "section": "1.2 JAVA语言进化史",
    "text": "1.2 JAVA语言进化史",
    "crumbs": [
      "Home",
      "点击查看-->详细目录<--"
    ]
  },
  {
    "objectID": "content.html#延伸阅读",
    "href": "content.html#延伸阅读",
    "title": "目录",
    "section": "1.3 延伸阅读",
    "text": "1.3 延伸阅读\n\n1.3.1 终身仁慈独裁者\n\n\n1.3.2 Java的名字是谁起的？\n\n\n1.3.3 James Gosling如何回答相比于C语言，Java不够自由？\n\n\n1.3.4 Java的现状怎么样？",
    "crumbs": [
      "Home",
      "点击查看-->详细目录<--"
    ]
  },
  {
    "objectID": "content.html#传统java版的hello-world-17-1",
    "href": "content.html#传统java版的hello-world-17-1",
    "title": "目录",
    "section": "1.1 “传统”JAVA版的HELLO WORLD 17",
    "text": "1.1 “传统”JAVA版的HELLO WORLD 17\n2.1.1 编辑源代码 17 2.1.2 编译和运行 18 2.1.3 回顾写程序的流程 20 2.2 解析代码 21 2.2.1 注释 22 2.2.2 声明类 23 2.2.3 main方法 24 2.2.4 语句 25 2.3 调试程序 25 2.3.1 调试程序的步骤与方法 27 2.3.2 选择一个好用的开发环境 27 2.4 JAVA虚拟机简史 28 2.4.1 Oracle的HotSpot虚拟机 28 2.4.2 IBM OpenJ9虚拟机 29 2.4.3 BEA的JRockit 29 2.5 脱口秀：程序员，编译器，虚拟机 30 2.6 “未来”JAVA版的HELLO WORLD 31 2.7 附录 32 2.8 总结 32 3. 面向对象 35 3.1 第一门面向对象编程语言 35 3.1.1 面向对象的发源项目 35 3.1.2 Simula核心概念 36 3.1.3 Simula的普及 39 3.2 JAVA：一切皆对象 40 3.2.1 什么是“对象” 40 3.2.2 “对象”有什么用？ 42 3.3 面向对象编程为什么这么难 43 3.3.1 名词搅拌器 43 3.3.2 滥用隐喻 44 3.3.3 过度宣传 45 3.4 面向对象编程可以很简单 46 3.4.1 FIFA足球游戏 47 3.4.2 设计孤立的类很简单 48 3.4.3 类之间的关系才是难点 51 3.5 脱口秀：面向对象的优点 59 3.6 总结 67 4. 变量 69 4.1 变量的历史 70 4.2 变量名 70 4.3 变量的数据类型 72 4.3.1 基本数据类型的变量 74 4.3.2 引用数据类型的变量 84 4.4 变量作用域 85 4.4.1 Java中变量的作用域 85 4.4.2 作用域的历史 86 4.4.3 故事：动态作用域和静态作用域 88 4.5 本章附录 91 4.5.1 计算机中小数处理的历史 91 4.5.2 计算机中字符处理的历史 95 4.6 总结 99 5. 操作符 102 5.1 算术操作符 104 5.2 赋值操作符 105 5.3 关系操作符 107 5.4 逻辑操作符 110 5.4.1 逻辑“与”（AND） 110 5.4.2 逻辑“或”（OR） 111 5.4.3 逻辑“非”（NOT） 113 5.5 自增、自减操作符 113 5.6 位操作符 114 5.7 三元操作符 116 5.8 操作符的优先级 117 5.9 本章附录 118 5.10 总结 121 6. 结构化编程 122 6.1 结构化编程的由来 123 6.2 顺序结构 124 6.2.1 前后顺序无关的代码 125 6.2.2 有明确顺序的代码 126 6.3 选择结构 127 6.3.1 if语句 128 6.3.2 switch语句 131 6.4 循环结构 138 6.4.1 do-while循环 139 6.4.2 while循环 140 6.4.3 for循环 142 6.4.4 增强的for循环 143 6.4.5 break和continue 145 6.4.6 标签 147 6.4.7 小结 148 6.5 本章附录 149 6.6 总结 151 7. 方法 153 7.1 方法的概述 153 7.2 方法的声明与调用 155 7.3 方法的参数 156 7.3.1 命名参数 158 7.3.2 可变参数 160 7.3.3 形参与实参 162 7.4 方法的返回值 162 7.5 递归 168 7.5.1 递归步骤与终止条件 168 7.5.2 递归实现科赫雪花 169 7.6 总结 173 8. 数组 174 8.1 数组概述 174 8.2 数组的声明 174 8.3 数组的初始化 175 8.3.1 静态初始化 175 8.3.2 动态初始化 176 8.4 多维数组 178 8.4.1 二维数组 178 8.4.2 三维数组 180 8.5 用数组实现本福特定律 181 8.6 总结 183 9. 类、对象和封装 185 9.1 类与对象 186 9.2 属性与方法 186 9.2.1 访问修饰符 188 9.2.2 getter 和 setter方法 189 9.2.3 构造函数 193 9.2.4 如何使用this关键字 196 9.3 静态成员 198 9.4 总结 200 10. 包 202 10.1 包的简介 202 10.2 语法和用法 202 10.2.1 如何声明package 202 10.2.2 如何导入包 203 10.2.3 如何使用package中的成员 205 10.3 最佳实践 206 10.3.1 如何命名包 206 10.3.2 以包为结构组织项目代码 206 10.4 总结 207 11. 继承 209 11.1 继承的语法 209 11.2 类实例的继承机制 210 11.2.1 子类可以继承父类的属性么？ 210 11.2.2 子类可以继承父类的方法么？ 212 11.2.3 子类可以继承父类的构造函数么？ 214 11.2.4 如何使用super关键字？ 215 11.3 静态成员的继承机制 218 11.4 不可被继承的类和方法 220 11.4.1 final用于修饰类是阻止类继承 220 11.4.2 final用于修饰方法是阻止方法被覆盖 220 11.5 总结 222 12. 抽象类 224 12.1 抽象类概述 224 12.2 抽象类的实现 225 12.3 总结 229 13. 接口 230 13.1 接口小史 230 13.2 接口的定义与实现 231 13.3 接口与抽象类 233 13.3.1 接口的作用 233 13.3.2 接口与抽象类的区别 233 13.4 接口引入DEFAULT方法 238 13.5 接口中引入静态方法 240 13.6 接口的继承与多重继承 243 13.7 总结 246 14. 多态 248 14.1 用继承来实现多态 248 14.1.1 方法（Override）重写为多态提供基础 248 14.1.2 向上转型（Upcasting）为多态提供统一调用方式 250 14.2 用接口（INTERFACE）实现多态 253 14.3 用继承跟用接口实现多态有什么不同？ 256 14.4 用泛型实现多态 257 14.5 总结 257 15. 集合 260 15.1 集合的基本概念 262 15.1.1 什么是集合 262 15.1.2 集合与数组的区别 263 15.2 JAVA集合框架的架构体系 264 15.3 核心接口与实现类 266 15.3.1 Iterable接口 266 15.3.2 Collection接口 266 15.3.3 List接口以及实现类 267 15.3.4 Set接口以及实现类 269 15.3.5 Map接口以及实现类 272 15.4 本章附录 275 15.5 总结 277 16. 错误处理 279 16.1 异常基础概念 279 16.1.1 什么是异常 279 16.1.2 异常的类型和层次结构 279 16.1.3 Error和Exception的区别 281 16.2 异常捕获处理 282 16.2.1 throws语句 282 16.2.2 try-catch-finally语句 283 16.3 JAVA内置的常见异常类型 286 16.3.1 非受检异常（Unchecked Exception） 286 16.3.2 受检异常（Checked Exceptions） 287 16.3.3 错误（Error）： 287 16.4 自定义异常 288 16.5 异常链 290 16.6 异常与资源管理 292 16.7 总结 294 17. 泛型 296 17.1 泛型的概念与作用 296 17.1.1 Java泛型的历史 297 17.1.2 泛型的用途与语法 298 17.2 定义泛型类 300 17.3 定义泛型接口 302 17.4 定义泛型方法 304 17.4.1 泛型方法和多态 306 17.4.2 泛型方法与泛型类、泛型接口的区别 306 17.5 类型通配符的概念与使用场景 307 17.5.1 无界通配符 ( ? ) 307 17.5.2 上界通配符 （ &lt;? extends XXX&gt; ） 308 17.5.3 下界通配符（ &lt;? super XXX&gt; ） 309 17.5.4 通配符的PECS原则(Producer Extends,Consumer Super) 310 17.6 泛型的继承与子类型规则 310 17.6.1 泛型的不变性规则及其影响 310 17.6.2 通配符的协变规则与逆变规则 313 17.7 泛型中的类型擦除 314 17.7.1 什么是类型擦除 314 17.7.2 JVM在编译时如何处理泛型 315 17.7.3 类型擦除对编程的影响 315 17.7.4 泛型与数组 316 17.8 总结 316 18. 函数式编程 318 18.1 第一门函数式编程语言：LISP语言 318 18.1.1 Lisp简介 318 18.1.2 Racket以及Racket的语法 319 18.2 LAMBDA表达式 321 18.2.1 什么是Lambda表达式 321 18.2.2 无参数的Lambda表达式 321 18.2.3 有一个参数的Lambda表达式 323 18.2.4 有两个参数的Lambda表达式 323 18.2.5 将Lambda表达式赋值给变量 324 18.3 函数式接口 325 18.3.1 为什么需要函数式接口 325 18.3.2 函数式接口的种类有多少 325 18.3.3 函数式接口为何只能有一个抽象方法？ 326 18.3.4 方法引用 327 18.3.5 自定义函数式接口 327 18.4 STREAM API 329 18.4.1 什么是Stream 329 18.4.2 创建Stream的各种方式 330 18.4.3 Stream操作的分类 331 18.4.4 常见的中间操作 334 18.4.5 常见的终端操作 338 18.5 总结 344 19. 枚举类型 346 19.1 枚举概述 346 19.1.1 什么是枚举 346 19.1.2 枚举和常量的区别 347 19.2 定义枚举 347 19.3 枚举的高级特性 350 19.3.1 枚举类型不能继承，但是可以实现接口 350 19.3.2 枚举无法被实例化 351 19.3.3 枚举常量实例最好设置为final 351 19.3.4 不能依赖于枚举常量的序数 351 19.3.5 values()和valueOf()方法 352 19.3.6 EnumSet和EnumMap 352 19.4 总结 355 20. 注解 357 20.1 什么是注解 357 20.2 在代码中使用JAVA预定义的注解 358 20.2.1 注解与注释的区别 358 20.2.2 使用Java预定义的注解 359 20.3 在代码中使用自定义的注解 361 20.3.1 定义注解 361 20.3.2 使用注解 362 20.3.3 解析注解 362 20.4 总结 363 21. 反射 365 21.1 反射的历史与发展 366 21.1.1 起初，反射仅仅是为了跨平台 366 21.1.2 后来，反射的发展就出乎意料了 368 21.2 获取CLASS对象 368 21.2.1 示例代码 369 21.2.2 获取Class对象的三种方式 371 21.3 基础的反射API 374 21.3.1 构造类操作 375 21.3.2 属性类操作 377 21.3.3 方法类操作 379 21.4 METHODHANDLE和VARHANDLE 382 21.5 反射的局限 385 21.5.1 性能开销问题 385 21.5.2 破坏封装性 385 21.5.3 反射代码往往难以维护 385 21.6 总结 386",
    "crumbs": [
      "Home",
      "点击查看-->详细目录<--"
    ]
  },
  {
    "objectID": "content.html#传统java版的hello-world",
    "href": "content.html#传统java版的hello-world",
    "title": "目录",
    "section": "0.1 “传统”JAVA版的Hello World",
    "text": "0.1 “传统”JAVA版的Hello World\n2.1.1 编辑源代码 17 2.1.2 编译和运行 18 2.1.3 回顾写程序的流程 20 2.2 解析代码 21 2.2.1 注释 22 2.2.2 声明类 23 2.2.3 main方法 24 2.2.4 语句 25 2.3 调试程序 25 2.3.1 调试程序的步骤与方法 27 2.3.2 选择一个好用的开发环境 27 2.4 JAVA虚拟机简史 28 2.4.1 Oracle的HotSpot虚拟机 28 2.4.2 IBM OpenJ9虚拟机 29 2.4.3 BEA的JRockit 29 2.5 脱口秀：程序员，编译器，虚拟机 30 2.6 “未来”JAVA版的HELLO WORLD 31 2.7 附录 32 2.8 总结 32",
    "crumbs": [
      "Home",
      "点击查看-->详细目录<--"
    ]
  },
  {
    "objectID": "chapter2.html#bytecode是什么",
    "href": "chapter2.html#bytecode是什么",
    "title": "第2章 第一行代码",
    "section": "4.1 bytecode是什么？",
    "text": "4.1 bytecode是什么？\n我在IBM Developer上曾经看过一篇文章，文章的名字叫Java bytecode: Understanding bytecode makes you a better programmer在这篇文章里，作者说：“对Java程序员来说，理解bytecode类似于让C/C++程序员理解汇编语言”。\n\n\n\n\n\n\nKathleen Booth与汇编语言\n\n\n\nKathleen Booth女士在1947年发明了汇编语言，并且设计了伦敦大学第一个汇编程序与自动解码。\n汇编语言是一种非常低级的语言，一般不能在不同的平台之间移植。可以把汇编语言看作是机器语言的助记符，在不同的设备上有不同的机器语言指令集。\n\n\n“bytecode”里的byte有真实的含义，代表byte，也就是8个bit。8 bits会产生256个组合。Java虚拟机最多支持256个操作符。目前，只用了大概80%。可以把bytecode理解为“Java虚拟机的机器码”。\njavac的工作就是把Java源代码转化成bytecode。 不管是在Linux上生成的bytecode，还是在Windows上生成的bytecode，都是一模一样的，这构成了java跨平台的基石。",
    "crumbs": [
      "Java编程",
      "第2章 Hello World"
    ]
  },
  {
    "objectID": "chapter1.html#指导java发展的两份文档",
    "href": "chapter1.html#指导java发展的两份文档",
    "title": "第1章：初识Java",
    "section": "1.2 指导Java发展的两份文档",
    "text": "1.2 指导Java发展的两份文档\nJava之父James Gosling的故事想必大家已经耳熟能详，如果不太熟悉的话，推荐到国外计算机历史网站Computer History Museum上观看访谈“James Gosling Oral History”, 这个视频共分为为两部分，分别为 https://youtu.be/Yjq3hZXYp_k 和 https://www.youtu.be/LaJtYHvpa68。在这份长达近七小时的访谈中，James Gosling谈了他本人和Java的方方面面。\n\n\n\n\n\n\nJames Gosling简介\n\n\n\n\n出生于1955年，加拿大人，Java语言创始人。获美国卡内基梅隆大学计算机科学博士学位，1984年加入Sun公司，在此，他研发了Java编程语言。\n\n\n1995年2月，James Gosling发布了一篇只有9页的文档来介绍Java，这篇文档的名字叫《Java: an Overview》。这篇文档简明扼要的指出了当时计算机界存在的问题，并且给出了Java的解决方案。\n随后在1995年10月，James Gosling和Henry McGilton发布了Java第一版白皮书：《The Java Language Environment》。这篇86页的文档详细的介绍了Java的技术细节。\n虽然日后Java发布过多份技术白皮书，但我认为这两份白皮书是Java所有白皮书中最重要的两份。在Java尚未被人所知的年代，James Gosling写的这两份文档，如同明灯一样，指明了Java前进的方向。\n现在25年过去了，在计算机领域，25年让计算机软硬件有了长足的发展，但是这两份文档对Java学习仍然非常有指导意义。\n这两份文档我读过很多次，坦白来讲，在技术领域，能指出问题的人不少，但是能做到抓住问题核心的同时又能提出有效解决方案的人则凤毛麟角。James Gosling做到了，从1995年到今天，Java的份额一路攀升到第一名，我想，在编程语言领域，没有比被程序员喜欢使用更好的赞美。\n接下来，我们一起学习一下这两份文档。看看编程碰到了哪些难题，Java又是如何解决的。",
    "crumbs": [
      "Java编程",
      "第1章 初始Java"
    ]
  },
  {
    "objectID": "chapter1.html#为什么james-golsling被称为终身仁慈独裁者",
    "href": "chapter1.html#为什么james-golsling被称为终身仁慈独裁者",
    "title": "第1章：初识Java",
    "section": "3.1 为什么James Golsling被称为终身仁慈独裁者？",
    "text": "3.1 为什么James Golsling被称为终身仁慈独裁者？\nJava的创始人James Gosling被称之为BDFL。\nBDFL的意思是终身仁独裁者BDFL（Benevolent Dictator For Life）是极少数软件开发者能拥有的头衔，一般是某个语言、某个项目的创始人。当软件社区出现争议并且无法和平解决的时候，要有一个最终的话事人来解决纷争。其它耳熟能详的BDFL有Linux的开发者Linus、Python的开发者吉多·范罗苏姆、Perl的作者Larry Wall、LLVM的设计者Chris Lattner等等。\n能够当BDFL的人，要有很强的领袖气质，能以德服人。而且，在编程领域中，独裁者是会“体面”的离开的。\n不止Java，像Python，JavaScript语言，都经历了开始主要由一个人主导，后来一个委员会主导，到最后，语言的创始人离开。2018年7月12日，Python 创始人 Guido van Rossum发邮件决定离开Python决策层，不再领导Python语言的开发。有兴趣的读者，可以找来那封信读一下。\n最后，终身仁慈独裁者，跟传统政治上的独裁者是两码事，举目全球，传统政治行业上的独裁者几乎没有了。",
    "crumbs": [
      "Java编程",
      "第1章 初始Java"
    ]
  },
  {
    "objectID": "chapter4.html#作用域的历史",
    "href": "chapter4.html#作用域的历史",
    "title": "第4章 变量",
    "section": "4.2 作用域的历史",
    "text": "4.2 作用域的历史\n假如我们能回到编程语言发展的早期阶段，会发现彼时的语言在处理变量命名方面往往面临着严峻的挑战。由于早期编程中的变量几乎都是全局作用域，所有变量名在整个程序中均处于可见状态，这就如同在一个班级中，若存在多位同名的学生“张伟”，当教师在点名时，这些“张伟”无法确认老师喊的是谁。这种情况下，命名冲突的问题频频出现，严重影响了代码的可读性、可维护性和程序运行的稳定性。\n假设一个班级中出现了多名 “张伟”的情况，解决冲突的根本方式是要求其中一些学生改名。然而，将这种解决方案应用到编程领域，在面对庞大且复杂的代码体系时，单纯依靠避免变量名称重复的做法是不实际的（实际上，改名的方法在班级中也不现实）。因此，科学家提出了“作用域”这一概念，即为变量名定义特定的有效范围，确保在不同区域内的同名变量互不影响，从而彻底解决了程序中的命名冲突问题。\n目前业界普遍采纳了两种作用域策略：一种是动态作用域，另一种则是静态作用域。Java语言采用的是静态作用域机制，这意味着变量的作用域在编译阶段即可确定，并且其可见性和生命周期与程序的执行流程无关，仅依赖于其在源代码中的声明位置。通过这样的设计，Java能够有效管理变量的使用和生命周期，保证了代码的准确性。\n静态作用域在编程语言的编译阶段即被明确规定。它通过源代码中定义变量的位置，来界定变量的有效可见区域。在静态作用域机制下，一个函数或代码块内部声明的变量的作用域是由该函数或代码块本身的定义位置所决定的，并不受到调用位置的影响。当程序实际执行时，对变量的引用解析将严格遵循其在原始源代码中的声明顺序。\n相反，动态作用域则是随着程序运行过程实时确定的。它以执行流程为基准，动态地界定变量的可见范围。在采用动态作用域的语言中，变量的有效性取决于当前正在执行的代码的上下文，而非其在源代码文本中的声明点。这意味着，查找并确定一个变量值的过程，会根据调用栈的具体状态以及代码的实际执行路径来进行。\n当前，大多数编程语言普遍采纳的是静态作用域机制，这一做法在业界已深入人心，以至于习以为常。然而，作用域的概念及其发展历程远比当下所广泛采用的方案更为复杂多样。Perl语言就是一个极富代表性的例子，它展示了作用域演进过程中的诸多挑战与变化。作为曾经的Perl程序员，我对Perl语言的作用域特性有着深刻的理解，可以说，Perl语言几乎踩了变量作用域中所有的“坑”。通过了解Perl语言对作用域的处理方式，我们可以更全面地了解作用域概念的发展脉络。\n故事的灵感来源于Perl语言的实际创始人Larry Wall，一位毕业于加利福尼亚大学洛杉矶分校的杰出程序员。关于Perl语言，他公开过大量的书、博客与邮件。他曾任职于知名科技企业Unisys和希捷公司，身兼系统管理员和系统程序员双重角色，并在职业生涯的某个阶段服务于美国国家安全局（NSA），参与了高度机密的项目研发。\nPerl语言诞生之初，正是为了应对从海量文本数据中高效提取关键信息这一迫切需求。接下来，我将通过一个虚构的故事来揭示Perl语言发展历程中的一个重要抉择：使用动态作用域，还是用静态作用域。希望这个故事可以帮助读者直观理解这两种作用域机制之间的本质区别。我将以第一人称的叙述方式，扮演故事中的主角进行虚构演绎。（在这本专注于Java语言的书中写Perl语言，希望能够为编程爱好者带来别样的乐趣与启示。）",
    "crumbs": [
      "Java编程",
      "第4章 变量"
    ]
  },
  {
    "objectID": "chapter4.html#虚构的故事动态作用域和静态作用域",
    "href": "chapter4.html#虚构的故事动态作用域和静态作用域",
    "title": "第4章 变量",
    "section": "4.3 虚构的故事：动态作用域和静态作用域",
    "text": "4.3 虚构的故事：动态作用域和静态作用域\n我是个程序员，我是计算机先驱，站在1986年人文和科技的十字路口上。\n今天是1986年6月22日，在世界杯决赛的赛场上，马拉多纳带领阿根廷进了英格兰两个球。马拉多纳在球场上疯狂地挑衅，而英国人则绅士般站在球场，任由“潘帕斯草原上的雄鹰翱翔”。哦，忘记说一件事了，英国是个绅士国家，挑衅英国人只有一个结果，英国人会上诉到法院。\n我不是阿根廷球迷，甚至，我不是足球球迷，但是今天我看到英格兰惨败，心里太高兴了，因为我的上司是个英国绅士，我的合作伙伴是英国公司，我已经快被工作压垮了，而上司却威胁我如果不能按期完成工作，那就法院见。\n对了，我还没有说我的工作是什么呢。我的工作叫数据处理程序员，就是坐在计算机前面处理数据的那种人，现在是1986年，干我们这一行的还没多少人，以后也许会多吧，谁知道呢。我要给伦敦证券交易所的那帮混蛋处理数据，他们的数据太多，变化更多，不是每天都要数据，而是每秒都要数据，我真的快要被逼疯了。\n我有一台最先进的计算机，但是只有几个蹩脚的工具，有两个处理文本数据的软件叫sed和awk，还有一个不好用的编程语言叫C语言，还有个shell，没有其它的了，这些工具像石器时代过来的，面对伦敦证券交易所每天产生的巨量数据，这些工具早晚会顶不住。\n\n\n\n\n\n\n当年Unix上流行的sed和AWK是什么?\n\n\n\nAWK是一种处理文本文件的语言，是一个强大的文本分析工具。特点是处理灵活，功能强大。可实现统计、制表以及其他功能。\n之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的Family Name的首字符。\nsed：Stream EDitor，流编辑器，它以行为单位处理字符流。\n目前几乎没人使用这两个工具了，在中文世界中，由于编码的问题，不能处理中文，因此用的更少。\n\n\n上帝保佑，如果我能有个更趁手的编程语言就好了，这个编程语言能够不像C语言一样每次使用前先编译，而是可以直接执行，这个语言还能和sed与awk完美结合。\n我知道现在没有，求人不如求已，只要有空闲，我自己做一个这样的编程语言吧。\n现在Apple公司很火，我也给我的编程语言起一个名字吧，就叫梨子语言，Pear语言吧。这个语言是我自己用的，所以设计得没那么精密，只要能完成工作就好。\n我有个优势，我有设计语言的条件，我妻子是个语言学家，她设计了一套语言，可以翻译多种版本的圣经，比我这个Pear语言可复杂多了。花了没多长时间，大概3个月吧，我这个语言就能运行了，至少再也不用写C语言了，伦敦证券交易所的那些数据每次都会有变动，再微小的修改，都要编译一次C语言，现在不用每次都编译了，我用得还是很开心的。\n我把我这个语言告诉了我的同事，他们提了一些意见，总归不用C语言了，还有一些同事提出要把sed和awk也整合进来，我觉得挺好的。\n又过了几个月，用我编程语言的人越来越多了，项目也快一年了，我打算把这个语言发到网上，如果有人喜欢，自己可以去编译一下，就发到unix的新闻组好了，就叫Pear kit 1.0吧。\n我获得了很多赞扬，但是也有人提出了一些bug，说这个语言不能很好地处理变量和作用域的问题。这个家伙发给我了一封邮件，我贴在这里，因为我的团队人不多，我还没遇到这个情况。\n亲爱的Pear创作人，你好：\n我非常喜欢你写的这个编程语言，每天都用得特别开心。我在工作中碰到了这样一个问题，因为我们是一个大型网站，有很多员工，Pear语言在设计的时候对变量使用的是对照表，我理解你这样设计的优点是很容易实现，对个人来说已经够快了，但是我的同事太多了，经常会给某个变量起相同的名字，所以，每次都要处理名字相同的问题。\n请问，有没有什么好办法或者好机制来处理名字相同的问题？\n邮件就是这样，我读了好几遍。没想到竟然有商业公司用Pear语言写程序，如果人一多，确实会出现他说的那个问题。我最初设计的时候确实没考虑这么多，为了说明这个情况，我来解释一下，以便大家知道这到底是个什么问题，看看下面这段代码：\nfor( i = 0; i &lt; 10; i++) {\n    process();\n    print i;\n}\nprocess() {\n    i = 0;\n}\n由于我设计得不严谨，前面的循环里用到了一个变量i，在循环里还调用了一个方法process，结果这个process方法里也用到了变量i，这样就把i的值改变了，导致上面的循环成了死循环。\n我设计这个语言的时候，根本没有考虑这么多，我用了最简单的方法，用对照表，对照表的方法类似于身份证，出现一个变量就去一个列表中去查找，并且不能出现相同名字的变量，这个方法简单、粗暴、有效。\n我暂时没想到好的解决方法，只好建议他尽量不要取相同的名字，或者如果有很多开发者的话，可以考虑每个开发者加上自己名字的前缀，比如lyd_i这样。\n或者用下面这种方法，在方法入口处先保存原来的值，等到处理完以后，在方法出口的时候再把保存的值返回给变量。\nprocess() {\n  old_i = i;\n  i = 0;\n  i = old_i;\n}\n这是个权益之计，我知道我要想办法解决这个问题了。这样写太麻烦了，人为增加了难度，也会增加出错的几率。可以把这种写法加上一个关键字local，有了这个关键字，可以让编程语言自己在程序入口处把值存起来，在方法出口处把值再复原回去。这样稍微减轻了一点工作量，上面这段代码可以这样写:\nprocess() {\n  local i;\n  i = 0;\n}\n直到又有一个人提出这个方法仍然有bug，这是我没想到的。我本以为是哪个人提出的无聊的问题，在我仔细看了邮件之后，才发现动态作用域的方法真的有严重的缺陷。\n看看下面的代码：\nx = \"global\"; \n\nprint_x() {\n    print x; \n}\n\nset_local() {\n    local x = \"local\";\n    print_x(); \n}\n在这段代码中，当set_local()函数调用print_x()时，尽管print_x()并未接收任何参数，其内部试图输出的变量x的值却受到了set_local()函数内局部变量的影响。这是不合常理的，当调用一个函数的时候，如果没有给这个函数传递参数，那么这个函数的行为是不能改变的。\n这个bug可以修吗？很难。如果要修，只能引入静态作用域，像C语言那样。但是，有这个必要吗？毕竟，我本来打算用动态作用域的……",
    "crumbs": [
      "Java编程",
      "第4章 变量"
    ]
  },
  {
    "objectID": "thanks.html",
    "href": "thanks.html",
    "title": "感谢大家的捧场",
    "section": "",
    "text": "别人写书，都是找一些有影响力的人写个推荐，但是，我环视四周，找不到有影响力的人。再说了，有影响力的人，都是彩虹屁一顿乱夸，人情世故。\n如果你有个人的社交媒体，愿意给我美言几句，把链接发给我，我会放在这里，谢谢。一定要记得发链接，否则看起来像我自己瞎编的，那不就尴尬了么？\n闻夸则喜，如果是骂我的，我们私下交流 :)\n\n\n示例：\n\n这本书写的不错（自卖自夸一下）。– 绿帽子大学校长🎩 https://liuyandong.com\n\n\n这是做读书节目以来，最想给观众介绍的一本书。 – 梁文道 https://liuyandong.com\n\n\n\n\n\n\n\nNote\n\n\n\n梁文道曾讲过一个故事，因为经常被上图书腰封，他曾致电出版社，得到的答复是：“全中国不止你一个人叫梁文道！",
    "crumbs": [
      "Java编程",
      "推荐与感谢"
    ]
  },
  {
    "objectID": "thanks.html#对本书的赞誉",
    "href": "thanks.html#对本书的赞誉",
    "title": "感谢大家的捧场",
    "section": "",
    "text": "示例：\n\n这本书写的不错（自卖自夸一下）。– 刘延栋 https://liuyandong.com\n\n\n这是做读书节目以来，最想给观众介绍的一本书。 – 梁文道 https://liuyandong.com\n\n\n\n\n\n\n\nNote\n\n\n\n梁文道曾讲过一个故事，因为经常被上图书腰封，他曾致电出版社，得到的答复是：“全中国不止你一个人叫梁文道！"
  },
  {
    "objectID": "thanks.html#对本书或者作者的赞誉",
    "href": "thanks.html#对本书或者作者的赞誉",
    "title": "感谢大家的捧场",
    "section": "",
    "text": "示例：\n\n这本书写的不错（自卖自夸一下）。– 绿帽子大学校长🎩 https://liuyandong.com\n\n\n这是做读书节目以来，最想给观众介绍的一本书。 – 梁文道 https://liuyandong.com\n\n\n\n\n\n\n\nNote\n\n\n\n梁文道曾讲过一个故事，因为经常被上图书腰封，他曾致电出版社，得到的答复是：“全中国不止你一个人叫梁文道！",
    "crumbs": [
      "Java编程",
      "推荐与感谢"
    ]
  },
  {
    "objectID": "pay.html",
    "href": "pay.html",
    "title": "“付款方式”与“学伴”社区",
    "section": "",
    "text": "1 付款方式\n目前我没有好的方式，也没有第三方可以担保，以后我可能会开个淘宝店什么的，但是目前还没有。\n\n\n2 “学伴”社区\n电子书很容易就复制了，可能我也赚不到什么钱。这200块钱里，有一项服务是不可取代的，我搞了一个社区，叫学伴，这个名字不是山东大学启发我的，网址是https://xueban.app。如果你购买了这4本书，我会给你一个社区的邀请链接，这个社区的主要话题是：学技术、学外语、搞事业。\n所谓的搞事业，有可能是学生想出国读书了，找个便宜点的国家；也有可能是找个远程工作，但是不知道怎么弄；也有可能是移民到国外，不要再这么卷了；如果你一直打工，到了35岁，HR发个邮件通知你，明天你不用来了，在社区里，咱们谈谈如何尽量避免这种情况…… 我以后会在电台里多邀请一些在国外学习工作生活的人，采访一下他们，给大家，包括我，开开眼界。\n\n\n\n\n\n\n如果没有审核资源，社区一定要有个付费墙\n\n\n\n有本书叫《怪诞行为学》，作者在书里讲了一种现象，如果你把布朗尼——一种 巧克力蛋糕——设置为免费，不管需要不需要，人们都会趋之若骛，排起长队。 只要你设置一个价格，哪怕只有1美分，也会让排队的人消失。他把这个现象起了个名字叫布朗尼效应。\n在中国，会更严重一点。如果你搞了个免费公开的社区，就会有人来请你喝茶——实际上没有茶，也没有水，更没有布朗尼蛋糕，只有写保证书，并关掉社区这一条路。我试过，可以说是赔了金钱又剪了网线，不能再细讲了。\n\n\n我卖电子书，也是践行搞事业的理念。打工了这么多年，我希望成为一个会做生意的人。目前，我理解的生意人，应该是提供相应的服务，收取相应的报酬。\n这4本书，我都会提供前4章的预览，你可以先看看前4章，再决定要不要花这个钱。我给这几本书定了一个上线的日期。\n\n\n\n\n\n\n\n\n\n书名\n目前完成度\n完整上线日期\n提供的格式\n\n\n\n\n《借助AI学习Java编程》\n100%\n2024.9.30前\npdf\n\n\n《借助AI用Java制作2D游戏》\n100%\n2024.12.31前\npdf\n\n\n《借助AI用Java制作GUI软件》\n90%\n2025.3.31前\npdf\n\n\n《Java Spring》\n50%\n2025.9.31前\npdf\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n我确实想提供epub的格式，但是…… 代码在epub里实在是太丑了，看不下去 :(\n\n\n从做电台来看，我还是比较能坚持的，我想做一个坚持长期主义的生意人。写书，录电台，录中英文编程视频…… 我也要践行学技术、学英语、搞事业的理念。\n既然结局已定，在死神来敲门之前，好好体验人生吧……我想成为做编程教学最好的电台主播，太虚的大话就不说了，免得像出书一样，被现实狠狠地打脸。\n\n\n\n\n\n\n只要加足够的定语，就一定能成为最好的。\n\n\n\n“我想成为做编程教学最好的电台主播”，肯定有人不相信，是的，我知道至少有一个人不相信。\n那么，我再加几个定语吧：我想成为做Java编程教学最好的山东籍电台男主播…… 只要定语足够多，那么，一定能成为最好的。",
    "crumbs": [
      "Java编程",
      "付款方式与学伴社区"
    ]
  },
  {
    "objectID": "pay.html#只要加足够的定语就一定能成为最好的",
    "href": "pay.html#只要加足够的定语就一定能成为最好的",
    "title": "“付款方式”与“学伴”社区",
    "section": "2.1 只要加足够的定语，就一定能成为最好的。",
    "text": "2.1 只要加足够的定语，就一定能成为最好的。\n“我想成为做编程教学最好的电台主播”，肯定有人不相信，是的，我知道至少有一个人不相信。\n那么，我再加几个定语吧：我想成为做Java编程教学最好的山东籍离异电台男主播…… 只要定语足够多，那么，一定能成为最好的。\n如果一个人，从来没有属于过你，那就无所谓失去。 —— 绿帽子大学校长\n技术可以随便学，毕竟艺不压身；婚不要随便结，人品一定要好，只做筛选，不做改变。若是遇人不淑，又滥生无辜，基本上，就插翅难飞了。—— 绿帽子大学校长\n在婚姻中，可以要求安全感，也可以要求仪式感，但是，不能要求有新鲜感。—— 绿帽子大学校长",
    "crumbs": [
      "Java编程",
      "付款方式与学伴社区"
    ]
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "发布日期",
    "section": "",
    "text": "这4本书，我都会提供前4章的预览，你可以先看看前4章，再决定要不要花这个钱。我给这几本书定了一个上线的日期。\n因为大部分内容我都写完了，我目前的工作主要是复制粘贴，希望每天能处理1-2章。\n\n\n\n书名\n目前完成度\n完整上线日期\n提供的格式\n\n\n\n\n《借助AI学习Java编程》\n100%\n2024.9.30前\npdf\n\n\n《借助AI用Java制作2D游戏》\n100%\n2024.12.31前\npdf\n\n\n《借助AI用Java制作GUI软件》\n90%\n2025.3.31前\npdf\n\n\n《Java Spring》\n50%\n2025.9.31前\npdf\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n我确实想提供epub的格式，但是……代码在epub里实在是太丑了，我是真的看不下去 :(\n\n\n我现在写了一些脚本，把markdown搞成LaTeX能识别的格式，然后用TeX Live生成pdf文件。不是很流畅，有人有好的建议没？\n现在的工作流程比较脆弱，出点小错误，LaTeX就死给你看……\n\n\n\n\n\n\n讲一下目前的流程吧\n\n\n\n这样，大家可以给我提一些意见什么的。我对我目前的工作流程不是很满意，一直在改进。\n\n我最初写初稿的时候，用的是LaTeX，说实在的，这个比较好用，但是只能自顾自的玩，如果你想出版，可以用word，可以用markdown。\n我就换了word，这是个非常错误的选择，我写的字数太多了，又加上我执迷于用索引来处理所有的文字，代码，图片与表格，牵一发而动全身啊……用word排版对我太难了。\n我现在要做的事情是把word再搞成markdown，然后生成web的样子，以及pdf的样子。\n我试了不少工具，生成epub实在是太难了，文字还好，但是代码肯定会乱掉，目前我没有好办法。\n我每天尽量处理1-2章。（复制粘贴到令人发狂）\n我非常希望找到一个类似Jupyter Notebook的工具，可以运行Java代码，而不是Python代码，都不是很理想。也许我应该自己山寨一个，一边复制Java代码，一边自动生成代码的结果，是我目前最希望要的功能。简单点的还行，一旦涉及到引入了过多的package，就不跑了……",
    "crumbs": [
      "Java编程",
      "发布日期"
    ]
  },
  {
    "objectID": "game-content.html",
    "href": "game-content.html",
    "title": "目录",
    "section": "",
    "text": "1 第1章 Hello World\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n先建了一个显示Hello World的用户界面，但是，这个界面并不适合游戏。原因是……\n游戏需要每秒刷新60帧，必须要让游戏获得主动权，而不是刷新率多少，一切随缘。\n\n\n1.1 创建Hello World应用程序\n1.1.1 Java Swing是什么？ \n1.1.2 为什么不能使用被动渲染？ \n1.2 使用主动渲染\n1.2.1 什么是主动渲染？\n1.2.2 定制主动渲染线程\n1.3.3 创建主动渲染窗口\n1.3 帧率是个大问题\n1.3.1 如果你电脑太慢会怎么样？\n1.3.2 如果你电脑太快会怎么样？\n1.3.3 如何把帧率固定在你想要的60帧？\n1.3.4 固定帧率非常难，比想象中的难太多了！\n\n\n\n\n\n\n2 第2章 交互\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n玩游戏、玩游戏，什么叫玩游戏？必须要与游戏交互才是玩游戏，否则那不成看电影了？\n那如何跟游戏交互呢？键盘和鼠标。\n\n\n2.1 什么是精灵\n2.1.1 精灵在游戏中的用途\n2.1.2 精灵的基本概念\n2.1.3 运动与动画\n2.2 如何处理键盘输入\n2.3 如何处理鼠标输入\n\n\n\n\n\n\n3 第3章 要学一点点数学了\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n可能有很多人一听数学，一个脑袋两个大，但是相信我，咱们不是考试，只要理解原理就好了。\n代码都是现成的，复制粘贴或者让AI来生成，一切搞定。\n\n\n3.1 笛卡尔坐标与极坐标\n3.1.1 笛卡尔坐标与极坐标的介绍\n3.1.2 两种坐标之间的转换\n3.1.3 游戏中的屏幕坐标\n3.2 向量\n3.2.1 向量的基本定义与表示\n3.2.2 2D游戏中向量的应用：位移、速度和加速度\n3.3 矩阵变换\n3.3.1 矩阵的基础概念与操作\n3.3.2 2D变换矩阵：平移、旋转和缩放\n3.3.3 矩阵乘法以及应用\n3.4 多维数组与矩阵\n3.4.1 行主序（Row-major order）矩阵\n3.4.2 列主序（Column-major order）矩阵\n\n\n\n\n\n\n4 第4章 碰撞检测\n\n\n\n\n\n\n\n\n\n\n\n\n不是你碰的，你为什么要扶她？\n开发2D游戏时，碰撞检测是一个重要的部分，用于处理角色与物体的交互、障碍物检测、敌人的反应等。\n\n\n\n4.1 基础碰撞检测技术\n4.1.1 轴对齐边界盒检测\n4.1.2 圆形测试相交检测\n4.1.3 圆形与矩形碰撞检测\n4.1.4 矩形与矩形碰撞检测\n4.2 高级碰撞检测技术\n4.2.1 凸多边形的碰撞检测\n4.2.2 分离轴定理（SAT - Separating Axis Theorem）\n4.2.3 像素级碰撞检测（Pixel-perfect Collision）\n4.2.4 精确检测复杂形状的碰撞\n4.2.5 使用Alpha通道处理透明区域\n4.3 有追求的人，仍旧可以精益求精\n4.3.1 使用空间分区技术优化碰撞检测\n4.3.1.1 四叉树（Quadtree）\n4.3.1.2 网格（Grid）方法\n4.3.2 减少不必要的碰撞检测\n4.3.2.1 广义阶段（Broad Phase）与精确阶段（Narrow Phase）\n4.3.3 使用Bounding Circle减少计算\n4.4 撞了以后怎么办？\n4.4.1 碰撞后的反弹与物体移动\n4.4.2 物体的摩擦力与阻力\n4.4.3 弹性碰撞与非弹性碰撞\n4.4.4 向量反射处理碰撞\n4.4.5 碰撞法线与物体反应\n4.4.6 使用向量预测碰撞\n\n\n\n\n\n\n5 第5章 LibGDX 和 JBox2D\n\n\n\n\n\n\n\n\n\n\n\n\n了解了碰撞的原理，实际上，是不用自己亲自动手的，只是我喜欢研究一下基本的原理。\n我们可以用一些现成的库，或者引擎来处理碰撞检测，比如LibGDX与JBox2D。\n说实话，写游戏的，没有不用引擎的。我搞的这本书，只是解释了什么叫2D引擎，浅尝辄止一下，继续研究底层原理。\n如果你搞懂了LibGDX这个2D引擎，就不看我这本书了，求求你不要搞懂！！\nLibGDX的源码在我心目中与Lua的源码，SQLite的源码，并列为三大“最尊重程序员”的开源代码，而不像Linux源码，看也看不懂，学也学不会，代码量又多，老虎吃天！\n这三个开源项目的代码，又纯又欲，推荐阅读。\n\n\n\n5.1 物理引擎与碰撞检测\n5.1.1 集成 Box2D 物理引擎\n  5.1.1.1 刚体（Rigid Bodies）的定义与使用\n  5.1.1.2 碰撞形状（Colliders）和力学属性\n5.1.2 使用 Box2D 进行碰撞检测\n5.1.3 处理物体的物理响应\n5.2 其它的无所不能的功能列举\n5.2.1 2D引擎也有输入处理\n5.2.1 声音与音乐必不可少\n5.2.3 2D图形与渲染、精灵也能处理\n5.2.4 场景管理也支持\n5.2.5 爆炸、烟花也能支持（离子系统）\n5.2.6 网络联机功能也不在话下\n5.3 引擎虽好，不要贪杯哦\n5.3.1 2D引擎千千万\n5.3.2 换了别的就完蛋\n5.3.3 还是要理解底层原理\n\n\n\n\n\n\n6 第6章 文件和资源\n\n\n\n\n\n\n\n\n\n\n\n\n声音，图像，关卡数据，一定是存在文件里的。好处至少有两点：\n第一，当增删查改数据的时候，不需要重新编译软件\n第二, 不想玩游戏了，可以保存，想玩了，可以读存档\n但是，这一章更多的是Java文件操作的内容，我也许应该放到Java那本书里。\n\n\n\n6.1 Java处理文件\n6.2 输入与输出流\n6.3 jar包\n6.4 XML文件\n\n\n\n\n\n7 第7章 图像\n\n\n\n\n\n\n\n\n\n\n\n\nJava是一门“古老”的语言，所以Java支持大量的图像格式，但是，如果做游戏，只需要理解两种图像格式就可以了。一种是BufferedImage，另一种是VolatileImage。\n\n\n\n7.1 BufferedImage格式的图片\n7.2 VolatileImage格式的图片\n7.3 创建透明图像\n7.4 使用alpha合成\n7.5 使用新技术绘制精灵\n\n\n\n\n\n8 第8章 声音\n\n\n\n\n\n\nWarning\n\n\n\n\n\n\n\n\n\n没有声音的游戏，缺少灵魂。\n\n\n\n8.1 声音API介绍\n8.2 使用Clip类加载和播放音效\n8.3 调整音量和音效\n8.4 使用SourceDataLine播放背景音乐\n8.5 在游戏中触发声音事件\n\n\n\n\n9 第9章 字体\n\n\n\n\n\n\n\n\n\n\n\n\n游戏中要显示字，显示字不难，难的是显示的字如何在游戏中协调。\n很多游戏，为了协调，会自己设计字体。英文还好，只有26个字母，大小写加起来不过60个。中文就比较要命了，至少几千个字 :)\n对中文字体设计者致以最高的敬意！\n\n\n\n9.1 字体的基础知识\n9.1.1 字体的基本概念\n9.1.2 字体的格式（TrueType与OpenType）\n9.1.3 字体的创建与管理\n9.2 加载自定义字体\n9.2.1 从文件中加载自定义字体\n9.2.2 设置字体样式和大小\n9.2.3 绘制文本\n9.2.4 排版与渲染效果\n9.3 处理多语言和国际化\n\n\n\n\n\n10 第10章 至此，引擎所有的知识已经讲差不多了\n\n\n\n\n\n\n\n\n\n\n\n\n如何把功能相关的类组织到一起呢？答案是用“包”。\n\n\n\n10.1 包的简介\n10.2 包的语法与用法\n10.2.1 如何声明包\n10.2.2 如何导入包\n10.2.3 如何使用包中的成员\n10.3 使用包的最佳实践\n10.3.1 如何命名包？\n10.3.2 如何以包为结构组织项目代码\n\n\n\n\n\n11 第11章 继承\n\n\n\n\n\n\n\n\n\n\n\n\n权力可以继承，财富可以继承，代码就不可以继承么？当然能！\n继承最重要的功能是为了代码重用，减少代码的重复。官/富二代最重要的功能也是继承富一代的权与钱，减少从零奋斗的过程。\n\n\n\n11.1 什么是继承\n11.2 类实例的继承机制\n11.2.1 子类可以继承父类的属性么？\n11.2.2 子类可以继承父类的方法么？\n10.2.3 如何使用super关键字？\n11.3 静态成员的继承机制\n11.4 不可被继承的类和方法\n11.4.1 final用于修饰类是用来阻止类被继承\n11.4.2 final用于修饰方法是阻止方法被覆盖\n11.5 多重继承的问题\n\n\n\n\n\n12 第12章 抽象类\n\n\n\n\n\n\n\n\n\n\n\n\n在《公孙龙子·白马论》中提出了“白马非马”的诡辩，如果第二个马是抽象类的话，那么“白马”就是“马”。“公孙龙”认为“马”不能实例化，但是“白马”可以实例化。\n我认为战国时期的公孙龙所持有的“每个事物只能是它自己，事物间不存在联系”的观点是错误的，至少在面向对象中是如此。\n不能实例化的“马”，在面向对象编程中叫“抽象类”。\n\n\n\n12.1 抽象类概述\n12.2 抽象类的实现\n\n\n\n\n\n13 第13章 接口\n\n\n\n\n\n\n\n\n\n\n\n\n在11章里讲过，Java不能多重继承，爸当官，妈当官，难道孩子不能同时继承两者的权力与财富么？在现实中，肯定能！（不信你看哪个公子，哪条鲶鱼，都是多重继承的……）\n但是在Java中却不能，Java不支持多重继承，如果你需要多重继承怎么办？用接口。\nhttp://www.gotw.ca/publications/c_family_interview.htm 在这篇访谈中，C++的作者与Java的作者，都谈到了编程语言的设计，其实Java的作者对接口与类的设计也不满意。\n\n\n\n13.1 接口的历史\n13.2 接口的定义与实现\n13.3 接口与抽象类\n13.4 接口引入DEFAULT方法\n13.5 接口中引入静态方法\n13.6 接口的继承与多重继承\n13.6.1 接口的作用\n13.6.2 接口与抽象的区别\n\n\n\n\n\n14 第14章 多态\n\n\n\n\n\n\n\n\n\n\n\n\n什么动物婴儿时四条腿，成年后两条腿，老年时三条腿？答案是：人。\n当我们调用走路的时候，同样的人，但是有不同的走路形态，小时候爬，长大后两条腿，老年后拄着一根拐杖。\n这就是多态，用统一的方式（走路），却实现了不同的形态（爬，走，拄拐）。\n本章介绍了如何用不同的方法实现多态。\n\n\n\n14.1 用继承来实现多态\n14.1.1 方法重写（Override）为多态提供基础\n14.1.2 向上转型（Upcasting）为多态提供统一调用方式\n14.2 用接口来实现多态\n14.3 用继承与用接口实现多态有什么不同？\n14.4 用泛型来实现多态\n\n\n\n\n\n15 第15章 集合\n\n\n\n\n\n\n\n\n\n\n\n\n第8章的时候，我“黑”了一下数组，数组作为一种数据结构，实在是太原始了。\n那用什么方法来代替数组呢？就是本章讲的集合。\n集合比数组好用太多了，不一个时代的产品。\n\n\n\n15.1 集合的基本概念\n15.1.1 什么是集合\n15.1.2 集合与数组的区别\n15.2 Java集合框架的架构体系\n15.3 集合的核心接口与实现类\n15.3.1 Iterable接口\n15.3.2 Collection接口\n15.3.3 List接口以及实现类\n15.3.4 Set接口以及实现类\n15.3.5 Map接口以及实现类\n\n\n\n\n\n16 第16章 异常处理\n\n\n\n\n\n\n\n\n\n\n\n\n嫦娥应悔偷灵药，碧海青天夜夜心。\n嫦娥犯的错，只能无限的懊悔，毕竟没有后悔药卖。但是Java中，为异常处理设置了非常多的防御措施，确保嫦娥偷不到灵药，防患于未然 :)\n\n\n\n16.1 异常的基础概念\n16.1.1 什么是异常\n16.1.2 异常的类型和层次结构\n16.1.3 Error和Exception的区别\n16.2 异常捕获处理\n16.2.1 throws语句\n16.2.2 try-catch-finally语句\n16.3 Java内置的常见异常类型\n16.3.1 非受检异常（Unchecked Exception）\n16.3.2 受检异常（Checked Exceptions）\n16.3.3 错误（Error）\n16.4 自定义异常\n16.5 异常链\n16.6 异常与资源管理\n\n\n\n\n\n17 第17章 函数式编程\n\n\n\n\n\n\n\n\n\n\n\n\n绝大部分Java编程书上，都不讲泛型，一是太难，二是觉得没什么用。但是，看看下面的语言：\nJava之前不支持泛型，Java 5之后增加了泛型。\nC#之前不支持泛型，C# 2.0之后增加了泛型。\nGo语言之前不支持泛型，G为1.18之后增加了泛型。\n难肯定是难的，有用肯定是有用的，花点时间是值得的。\n泛型解决的问题与继承、多态解决的问题是一脉相承的：代码复用。比如容器中可以存整数，也可存小数，还可以存小猫小狗这样的对象……如果逻辑一样，一点小改动就要重新调整代码，自己也受不了……\n现实中也是如此，油罐车可以拉煤油，可以拉汽油，甚至可以拉食用油……这当然可能会出现各种安全问题，所以需要很多的技术来确保安全。\n\n\n\n17.1 泛型的概念与作用\n17.1.1 Java泛型的历史\n17.1.2 泛型的用途与语法\n17.2 如何定义泛型类？\n17.3 如何定义泛型接口？\n17.4 如何定义泛型方法？\n17.4.1 泛型方法和多态的区别\n17.4.2 泛型方法与泛型类、泛型接口的区别\n17.5 类型通配符的概念与使用场景\n17.5.1 无界通配符（?）的概念与使用场景\n17.5.2 上界通配符（\\&lt;? extends XXX\\&gt;）的概念与使用场景\n17.5.3 下界通配符（\\&lt;? super XXX\\&gt;）的概念与使用场景\n17.5.4 通配符的PECS(Producer Extends,Consumer Super)原则\n17.6 泛型的继承与子类型规则\n17.6.1 泛型的不变性规则及其影响\n17.6.2 通配符的协变规则与逆变规则\n17.7 泛型中的类型擦除\n17.7.1 什么是类型擦除\n17.7.2 JVM在编译时如何处理泛型\n17.7.3 类型擦除对编程的影响\n17.7.4 泛型对数组的影响\n\n\n\n\n\n18 第18章 函数式编程\n\n\n\n\n\n\n\n\n\n\n\n\n离婚的原因是什么？千千万万，但是最重要的一个是：心变了。\nbug的原因是什么？千千万万，但是最重要的一个是：状态变了。\n什么叫状态变了呢？64核的CPU中，有1个核修改了全局变量，但其它63个核不知道；有个文件被修改了，但其它进程不知道…… 状态改变，是bug的高发原因。\n如何让离婚率变为0？方法是减少结婚，有感情的就同居得了。\n如何让bug减少？方法是减少命令式编程，增加函数式编程。\n于是，随着CPU核心的增多、分布式、协同式程序的增多，不改变程序状态的函数式编程“死灰复燃”了……\n本章从Lisp历史谈起，让大家清晰的了解什么叫函数式编程，为何Java的函数式编程不如Lisp那么优雅……\n\n\n\n18.1 第一门函数式编程语言：LISP语言\n18.1.1 Lisp简介\n18.1.2 Racket以及Racket的语法\n18.2 Lambda表达式\n18.2.1 什么是Lambda表达式\n18.2.2 无参数的Lambda表达式\n18.2.3 有一个参数的Lambda表达式\n18.2.4 有两个参数的Lambda表达式\n18.2.5 如何将Lambda表达式赋值给变量？\n18.3 函数式接口\n18.3.1 为什么需要函数式接口?\n18.3.2 函数式接口的种类有多少?\n18.3.3 函数式接口为何只能有一个抽象方法？\n18.3.4 方法引用\n18.3.5 如何自定义函数式接口?\n18.4 Stream API\n18.4.1 什么是Stream\n18.4.2 创建Stream的各种方式\n18.4.3 Stream操作的分类\n18.4.4 常见的中间操作\n18.4.5 常见的终端操作\n\n\n\n\n\n19 第19章 枚举类型\n\n\n\n\n\n\n\n\n\n\n\n\n在Java中，枚举已经强大到什么地步了呢？几乎所有类能做的事情，枚举都能做。枚举是一种特殊的类。\n枚举不止是简单的常量的集合，还可以拥有属性、方法和构造函数。还支持接口和实现。\n简单来说，枚举是受限的类。\n\n\n\n19.1 枚举概述\n19.1.1 什么是枚举\n19.1.2 枚举和常量的区别\n19.2 定义枚举\n19.3 枚举的高级特性\n19.3.1 枚举类型不能继承，但是可以实现接口\n19.3.2 枚举无法被实例化\n19.3.3 枚举常量实例最好设置为final\n19.3.4 不能依赖于枚举常量的序数\n19.3.5 values()和valueOf()方法\n19.3.6 EnumSet和EnumMap\n\n\n\n\n\n20 第20章 注解\n\n\n\n\n\n\n\n\n\n\n\n\n注解是Java 5之后引入的。\n对司机而言，开车的时候，最重要的信息是路上的指示牌。比如看到“前方有急转弯”，你就会注意一点。\n同样，注解类似于这些路牌，当看到@Override的时候，编译器会去查一下父类中是否有这个方法，当看到@Deprecated的时候，会提示这个方法已经过时了……\n注解的本质是提供额外的元数据和指示，帮助编译器、工具和开发者更好地理解和处理代码。\n\n\n\n20.1 什么是注解\n20.2 在代码中使用Java预定义的注解\n20.2.1 注解与注释的区别\n20.2.2 使用Java预定义的注解\n20.3 在代码中使用自定义的注解\n20.3.1 定义注解\n20.3.2 使用注解\n20.3.3 解析注解\n\n\n\n\n\n21 第21章 反射\n\n\n\n\n\n\n\n\n\n\n\n\n据说，违反法律最刺激，要是违反了法律还不被制裁，就更是刺激了。比如古人有云：“妻不如…”，这句话你自己去搜搜吧。\n前面我们讲类的作用，又是封装，又是隐藏。然后突然来一个机制，啥封装，啥隐藏？直接给你显微镜下看的明明白白的……是不是很刺激？\n反射就是这样的，使用反射，咱们可以正在光明的走后门，所有的类定义的条条框框，都可以不用遵守。让你觉得像个特权阶级。\n\n\n\n21.1 反射的历史与发展\n21.1.1 起初，反射仅仅是为了跨平台\n21.1.2 后来，反射的发展就“失控”了\n21.2 获取Class对象\n22.2.1 Class对象是Java反射机制的基础\n22.2.2 获取Class对象的三种方式\n21.3 基础的反射API\n21.3.1 构造类操作\n21.3.2 属性类操作 \n21.3.3 方法类操作\n21.4 MethodHandler和VarHandle\n21.5 反射的局限\n21.5.1 性能开销问题\n21.5.2 破坏封装性\n21.5.3 反射代码往往难以维护\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n这本书写了21章，而且肯定还有很多内容没有覆盖到，如果我说一些漂亮话，什么“书山有路勒为径，学海无涯苦作舟”，让大家再多学点什么的，一般人实际上内心是比较崩溃的。\n那学到什么时候是个头啊？！\n实际上，你根本不需要学这么多。我之所以写这么多，是因为这是“写书”，其目的是“尽量覆盖”，而现实中做项目，其目的是“尽快做完下班”。\n如果你继续读我剩下的三本书，你会发现，每本书都只是用到这本书里“部分内容”，比如做游戏，你就用不到反射，也用不到函数编程，因此会不会这些稀奇古怪的东西，对开发游戏完全没影响。",
    "crumbs": [
      "Java编程",
      "点击查看完整目录"
    ]
  }
]